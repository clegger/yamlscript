# Copyright 2023 Ingy dot Net
# This code is licensed under MIT license (See License for details)

- name: Test label / description
  yamlscript: |
  clojure: |
  TEMPLATE: true


- name: Simple map pair expression
  yamlscript: |
    !yamlscript/v0
    foo: bar
  clojure: |
    (foo bar)


- name: An 'if' statement
  yamlscript: |
    !yamlscript/v0
    if (x > 10):
      foo(x)
      bar(x)
  clojure: |
    (if (> x 10) (foo x) (bar x))


- name: Double quoted string
  yamlscript: |
    !yamlscript/v0
    println: "foo"
  clojure: |
    (println "foo")


- name: Single quoted string
  yamlscript: |
    !yamlscript/v0
    println: 'foo'
  clojure: |
    (println "foo")


- name: Literal style string
  yamlscript: |
    !yamlscript/v0
    println: |-
      foo
  clojure: |
    (println "foo")


- name: Folded style string
  yamlscript: |
    !yamlscript/v0
    println: >-
      foo
  clojure: |
    (println "foo")


- name: rng operator
  yamlscript: |
    !yamlscript/v0
    say: (1 .. 10)
  clojure: |
    (say (rng 1 10))


- name: String concat operator
  yamlscript: |
    !yamlscript/v0
    (a + "-" + b)
  clojure: |
    (_+ a "-" b)


- name: String repeat operator
  yamlscript: |
    !yamlscript/v0
    ("foo" * 3)
  transform: |
    {:Lst [{:Sym _*} {:Str "foo"} {:Int 3}]}
  clojure: |
    (_* "foo" 3)


- name: Nested mappings
  yamlscript: |
    !yamlscript/v0
    foo:
      bar: baz
  resolve: |
    {:ysm [{:ysx "foo"} {:ysm [{:ysx "bar"} {:ysx "baz"}]}]}
  clojure: |
    (foo (bar baz))


- name: String interpolation
  yamlscript: |
    !yamlscript/v0
    say: "Hello $name $(inc 41) $dec(43)!"
  clojure: |
    (say (str "Hello " name " " (inc 41) " " (dec 43) "!"))


- name: Multi-line string interpolation
  yamlscript: |
    !yamlscript/v0
    say: |
      Dear $word(:name),

      Sincerely, $word(:name)
  clojure: |
    (say (str "Dear " (word :name) ",\n\nSincerely, " (word :name) "\n"))


- name: String interpolation escaped $
  yamlscript: |
    !yamlscript/v0
    say: "Hello \\$name"
  clojure: |
    (say "Hello $name")


- name: Automatically call the main function when defined
  yamlscript: |
    !yamlscript/v0
    defn main(name):
      say: "Hello $name"
    x =: 1
  clojure: |
    (defn main [name] (say (str "Hello " name)))
    (def x 1)
    (apply main ARGV)


- name: The => operator
  yamlscript: |
    !yamlscript/v0
    x =: 41
    =>: (x + 1)
  clojure: |
    (def x 41)
    (_+ x 1)


- name: (a + b + c) -> (+ a b c)
  yamlscript: |
    !yamlscript/v0
    =>: (a + b + c)
  clojure: |
    (_+ a b c)


- name: Pre-declare top level functions as needed
  yamlscript: |
    !yamlscript/v0
    defn foo():
      bar: 123
    defn bar(n):
      =>: 321
  clojure: |
    (declare bar)
    (defn foo [] (bar 123))
    (defn bar [n] 321)


- name: Pre-declare symbols not called as functions
  yamlscript: |
    !yamlscript/v0
    defn a():
      map b: (1 .. 3)
    defn b():
      c()
    defn c():
      =>: 123
  clojure: |
    (declare b c)
    (defn a [] (map b (rng 1 3)))
    (defn b [] (c))
    (defn c [] 123)


- name: The || or operator
  yamlscript: |
    !yamlscript/v0
    =>: (a || b)
  clojure: |
    (or a b)


- name: Multiple && and operators
  yamlscript: |
    !yamlscript/v0
    =>: (a && b && c)
  clojure: |
    (and a b c)


- name: Triplets without parens
  yamlscript: |
    !yamlscript/v0
    =>: a + b
  clojure: |
    (_+ a b)


- name: Multiple same operators without parens
  yamlscript: |
    !yamlscript/v0
    =>: a + b + c
  clojure: |
    (_+ a b c)


- name: The => operator inside parens
  yamlscript: |
    !yamlscript/v0
    =>: (=> 123)
  clojure: |
    123


- name: Code generation for let
  yamlscript: |
    !yamlscript/v0
    defn foo(x):
      y =: x + 1
      x =: y * x
      =>: x
  clojure: |
    (defn foo [x] (let [y (_+ x 1) x (_* y x)] x))


- name: Multiple pairs in let
  yamlscript: |
    !yamlscript/v0
    defn foo(x):
      y =: x + 1
      prn: y
      prn: x
      =>: x
  clojure: |
    (defn foo [x] (let [y (_+ x 1)] (prn y) (prn x) x))


- name: let in let
  yamlscript: |
    !yamlscript/v0
    defn foo(x):
      y =: x + 1
      prn: y
      x =: y * x
      prn: x
      =>: x
  clojure: |
    (defn foo [x] (let [y (_+ x 1)] (prn y) (let [x (_* y x)] (prn x) x)))


- name: let not first in defn
  yamlscript: |
    !yamlscript/v0
    defn foo(x):
      prn: x
      y =: x + 1
      prn: y
      =>: x + y
  clojure: |
    (defn foo [x] (prn x) (let [y (_+ x 1)] (prn y) (_+ x y)))


- name: let over lambda
  yamlscript: |
    !yamlscript/v0

    defn lol(x):
      y =: 2 * x
      =>: \(% + y)

    say:
      lol(10): 4
  clojure: |
    (defn lol [x] (let [y (_* 2 x)] (fn [_1] (_+ _1 y))))
    (say ((lol 10) 4))


- name: Default args
  yamlscript: |
    !yamlscript/v0
    defn increase(x n=1):
      =>: x + n
  clojure: |
    (defn increase
      ([x] (let [n 1] (increase x n)))
      ([x n] (+ x n)))
  SKIP: true

- name: Call main when program has one top level (defn main ...) form
  yamlscript: |
    !yamlscript/v0
    defn main():
      say: "Hello World"
  clojure: |
    (defn main [] (say "Hello World"))
    (apply main ARGV)


- name: Interpolate variable with - in it
  yamlscript: |
    !yamlscript/v0
    foo-bar =: "World"
    defn say-hi():
      say: "Hello $foo-bar!!"
  clojure: |
    (def foo-bar "World")
    (defn say-hi [] (say (str "Hello " foo-bar "!!")))


- name: Fully qualified symbols
  yamlscript: |
    !yamlscript/v0
    ys::std.say: ys
  clojure: |
    (ys.std/say ys)


- name: Lambda function
  yamlscript: |
    !yamlscript/v0
    foo =: \(% + %4)
  build: |
    {:ysm
     ([{:Sym def} {:Sym foo}]
      {:Lst
       [{:Sym fn}
        {:Vec [{:Sym _1} {:Sym _} {:Sym _} {:Sym _4}]}
        {:Lst [{:Sym +} {:Sym _1} {:Sym _4}]}]})}
  clojure: |
    (def foo (fn [_1 _ _ _4] (_+ _1 _4)))


- name: Lambda function 2
  yamlscript: |
    !yamlscript/v0
    map: \(str ((% / %3) + %2)) (1 .. 3)
  clojure: |
    (map (fn [_1 _2 _3] (str (_+ (/ _1 _3) _2))) (rng 1 3))


- name: Default mapping semantic is a list of pairs
  yamlscript: |
    !yamlscript/v0
    a:
      b c: d
      e: f g
  build: |
    {:ysm
     ({:Sym a}
      {:ysm
       ([{:Sym b} {:Sym c}]
        {:Sym d}
        {:Sym e}
        [{:Sym f} {:Sym g}])})}
  construct: |
    {:Top
     [{:Lst
       [{:Sym a}
        {:Lst [{:Sym b} {:Sym c} {:Sym d}]}
        {:Lst [{:Sym e} {:Sym f} {:Sym g}]}]}]}
  clojure: |
    (a (b c d) (e f g))


- name: let with function call in yaml
  yamlscript: |
    !yamlscript/v0
    defn a():
      b =:
        c: d
      =>: b
  clojure: |
    (defn a [] (let [b (c d)] b))


- name: multi-let with function call in yaml
  yamlscript: |
    !yamlscript/v0
    defn tree(width):
      stars =:  \(inc(%) * "*")
      spaces =: \(% * " ")
      top =:
        join:
          map:
            \(line width, %): (width..1)
  clojure: |
    (defn
     tree
     [width]
     (let
      [stars
       (fn [_1] (_* (inc _1) "*"))
       spaces
       (fn [_1] (_* _1 " "))
       top
       (join (map ((fn [_1] (line width _1)) (rng width 1))))]))


- name: Star operator in lambda
  yamlscript: |
    !yamlscript/v0
    say: \(inc(%) * 2)
  clojure: |
    (say (fn [_1] (_* (inc _1) 2)))


- name: Function call symbol ends with ?
  yamlscript: |
    !yamlscript/v0
    =>: (a? b)
  clojure: |
    (a? b)


- name: Chained path lookup
  yamlscript: |
    !yamlscript/v0
    =>: a.5."x y".z
  clojure: |
    (_. a 5 "x y" "z")


- name: Operator symbol with underscore prefix
  yamlscript: |
    !yamlscript/v0
    defn _+(a b): a + b
  clojure: |
    (defn _+ [a b] (+ a b))
