<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YAMLScript</title>
  <subtitle></subtitle>
  <link href="https://yamlscript.org/feed.xml" rel="self"/>
  <link href="https://yamlscript.org/"/>
  
    <updated>2023-12-25T00:00:00Z</updated>
  
  <id>https://yamlscript.org</id>
  <author>
    <name>Ingy döt Net</name>
    <email>ingy@yaml.com</email>
  </author>
  
    
    <entry>
      <title>Welcome to the YAMLScript Blog</title>
      <link href="https://yamlscript.org/posts/welcome-to-the-yamlscript-blog/"/>
      <updated>2023-10-26T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/welcome-to-the-yamlscript-blog/</id>
      <content type="html">
        <![CDATA[
      <p><strong>Greetings!</strong></p>
<p>Welcome to the YAMLScript blog. This is where we will introduce you to novel concepts about YAMLScript as the language evolves.</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>YAMLScript Advent 2023</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-01/"/>
      <updated>2023-12-01T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-01/</id>
      <content type="html">
        <![CDATA[
      <h3>Seasons Greetings, my YAML friends!</h3>
<p>What if I told you that you could write a <strong>program in YAML</strong> that would
generate a Christmas tree?</p>
<p>Well, you can! Here's how:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment">#!/usr/bin/env ys-0</span><br><br>defn main(&amp;<span class="token punctuation">[</span>width<span class="token punctuation">]</span>)<span class="token punctuation">:</span><br>  <span class="token key atrule">say</span><span class="token punctuation">:</span><br>    <span class="token key atrule">tree</span><span class="token punctuation">:</span> width <span class="token punctuation">|</span><span class="token punctuation">|</span> 5<br><br><span class="token key atrule">defn tree(width)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">top =</span><span class="token punctuation">:</span><br>    <span class="token key atrule">join "\n"</span><span class="token punctuation">:</span><br>      mapv \(line width<span class="token punctuation">,</span> %)<span class="token punctuation">:</span> width..1<br><br>  <span class="token key atrule">trunk =</span><span class="token punctuation">:</span> trunk(width) * 2<br><br>  <span class="token key atrule">=></span><span class="token punctuation">:</span> <span class="token string">"$top\n$trunk"</span><br><br><span class="token key atrule">defn trunk(num)</span><span class="token punctuation">:</span><br>  spaces(num) + "<span class="token important">*\n"</span><br><br>defn line(width<span class="token punctuation">,</span> <span class="token key atrule">num)</span><span class="token punctuation">:</span><br>  <span class="token comment"># stars is a lexically defined function</span><br>  <span class="token key atrule">stars =</span><span class="token punctuation">:</span> \(inc(%) * "<span class="token important">*")</span><br><br>  <span class="token key atrule">join ""</span><span class="token punctuation">:</span><br>    <span class="token key atrule">spaces</span><span class="token punctuation">:</span> num<br>    <span class="token key atrule">stars</span><span class="token punctuation">:</span> (width <span class="token punctuation">-</span> num) * 2<br><br><span class="token key atrule">defn spaces(num)</span><span class="token punctuation">:</span> num * " "</code></pre>
<p>Let's get a tree!</p>
<pre class="language-bash"><code class="language-bash">$ ys tree.ys<br>     *<br>    ***<br>   *****<br>  *******<br> *********<br>     *<br>     *</code></pre>
<p>That's a pretty nice tree, but it's a little small. Let's make it bigger!</p>
<pre class="language-bash"><code class="language-bash">$ ys tree.ys <span class="token number">10</span><br>          *<br>         ***<br>        *****<br>       *******<br>      *********<br>     ***********<br>    *************<br>   ***************<br>  *****************<br> *******************<br>          *<br>          *</code></pre>
<p>Welcome to the first day of YAMLScript Advent 2023!
We're going to be writing a lot of YAMLScript this month, so let's get started…</p>
<p>Wait! What is YAMLScript?</p>
<p>YAMLScript is a new programming language that uses YAML as its syntax.
You can do anything in YAMLScript that you can do in a language like
Python or JavaScript such as:</p>
<ul>
<li>Defining functions</li>
<li>Using variables</li>
<li>String manipulation and interpolation</li>
<li>Loops and conditionals</li>
<li>Importing modules</li>
<li>And more!</li>
</ul>
<p>YAMLScript looks and feels like an imperative programming language, but it's
actually a functional programming language.
This means that YAMLScript programs are made up of expressions that are
evaluated to produce a result.</p>
<p>But why would you even want to write a program in YAML?</p>
<p>YAMLScript is a full-featured, general purpose programming language, but it's
also designed to be a great language for writing YAML configuration files.
To that point, almost all YAML files are valid YAMLScript programs!
And they evaluate to the same result that a YAML loader would produce.</p>
<p>For example, here's a YAML file that defines a list of fruits:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># fruits.yaml</span><br><span class="token punctuation">-</span> apple<br><span class="token punctuation">-</span> banana<br><span class="token punctuation">-</span> cherry</code></pre>
<p>Let's run this file as a YAMLScript program:</p>
<pre class="language-bash"><code class="language-bash">$ ys fruits.yaml<br>$</code></pre>
<p>Nothing happens!</p>
<p>But why would anything happen? The program doesn't do anything!</p>
<p>It's the same as running this Python program:</p>
<pre class="language-python"><code class="language-python">$ python <span class="token operator">-</span>c <span class="token string">'["apple", "banana", "cherry"]'</span><br>$</code></pre>
<p>To <em>evaluate</em> a YAMLScript program, we need to use the <code>--load</code> option:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">--load</span> fruits.yaml<br><span class="token punctuation">[</span><span class="token string">"apple"</span>, <span class="token string">"banana"</span>, <span class="token string">"cherry"</span><span class="token punctuation">]</span><br>$</code></pre>
<p>We got some JSON back!
That's because by default, <code>--load</code> evaluates the YAMLScript and prints the
result as JSON.</p>
<p>What if we want to include these fruits in our YAML grocery list?
Let's try it:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># grocery-list.yaml</span><br><span class="token punctuation">-</span> bread<br><span class="token punctuation">-</span> <span class="token key atrule">fruits</span><span class="token punctuation">:</span> load("fruits.yaml")<br><span class="token punctuation">-</span> milk</code></pre>
<p>Let's add the <code>--yaml</code> option to print the result as YAML:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">--load</span> grocery-list.yaml <span class="token parameter variable">--yaml</span><br>- bread<br>- fruits: load<span class="token punctuation">(</span><span class="token string">"fruits.yaml"</span><span class="token punctuation">)</span><br>- milk<br>$</code></pre>
<p>That's not what we wanted!
We wanted the contents of the fruits list to be included in the grocery list.</p>
<p>But if you think about it, this is exactly what we asked for.
Since every YAML file is a valid YAMLScript program, it certainly should be
loaded just like any other YAML loader would do it.</p>
<p>Let's fix this to do what we want:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># grocery-list.yaml</span><br><span class="token tag">!yamlscript/v0/data</span><br><span class="token punctuation">-</span> bread<br><span class="token punctuation">-</span> <span class="token key atrule">fruits</span><span class="token punctuation">:</span> <span class="token tag">!</span> load("fruits.yaml")<br><span class="token punctuation">-</span> milk</code></pre>
<p>Now when we run it:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-l</span> <span class="token parameter variable">-Y</span> grocery-list.yaml<br>- bread<br>- fruits:<br>  - apple<br>  - banana<br>  - cherry<br>- milk<br>$</code></pre>
<p>There we go! We got our fruits!</p>
<p>So what did we do here?
We added 2 things:</p>
<ul>
<li>A <code>!yamlscript/v0/data</code> tag at the top</li>
<li>A <code>!</code> tag before the <code>load</code> function call</li>
</ul>
<p>We won't get into the details of what these tags mean today, but you'll learn
about them soon enough.</p>
<h3>YAMLScript Advent 2023 Teasers</h3>
<p>My name is <a href="https://github.com/ingydotnet">Ingy döt Net</a>.
I'm one of the original creators of the <a href="https://yaml.org/">YAML data language</a> and I lead the <a href="https://yaml.org/spec/1.2.2/ext/team/">YAML Language Development Team</a>.</p>
<p>I've been working on YAMLScript for about a year now, and I'm excited to finally
share it with you.
I believe that YAMLScript is going to take YAML to exciting new places, while
remedying many of its shortcomings, limitations and frustrations.
I hope you'll come to agree as you join me on this holiday season unwrapping of
the gift that is YAMLScript!</p>
<p>I also hope that you enjoyed this first day of the <strong>YAMLScript Advent 2023</strong>!
I'll be posting a new blog article every day this month, so stay tuned!
Well at least until December 25th, but I might keep going after that. :-)</p>
<p>Here's a sneak peek of some of the things to come:</p>
<ul>
<li>Installing and using <code>ys</code> — the YAMLScript interpreter</li>
<li>The history of YAMLScript</li>
<li>How YAMLScript is compiled and evaluated</li>
<li>How YAMLScript can fix many of YAML's problems</li>
<li>How to use YAMLScript like a YAML loader in any programming language</li>
<li>Is YAMLScript actually a Lisp???</li>
<li>Refactoring complicated YAML configurations with YAMLScript</li>
<li>Writing polyglot libraries in YAMLScript</li>
<li>What makes a YAML file a valid (or invalid) YAMLScript program?</li>
<li>Compiling YAMLScript to native binaries and shared libraries</li>
</ul>
<p>Hopefully you're as excited as I am to learn more about YAMLScript!</p>
<p>See you tomorrow!</p>
<p>&nbsp;</p>
<details><summary style="color:#888">Santa's little secrets...</summary>
<p>In December 2023 YAMLScript is a work in progress.</p>
<p>This is not to say that it's vaporware, or a toy proof of concept.
It has a working compiler, runtime and CLI.
It has unit tests that must pass for every commit pushed to the main branch.
It's well thought out and has a clear direction that I continually vet with a
small group of talented and trusted people.</p>
<p>But that in turn not to say that you should use it in production today.
I encourage you to start playing with it, and I'm committed to backwards
compatibility for stable releases.
But we're not quite there yet.
Caveat usor!</p>
<p>YAMLScript is evolving fast.
While I'm writing these posts, I'm also writing the code for new features and
fixing bugs as I go.
I've had the Advent plan for over a month now, and I had planned to be further
along before December 1st, but such are the time estimates of hackers.</p>
<p>I am attempting to make sure that the code examples in these posts are always
using the implemented features, but sometimes I may fall a few hours behind.
Often I need to write the examples using code patterns that actually work but
are not the ones I preferred to best make a point.</p>
<p>As I fix bugs, implement features and tweak the language, I will update the
posts accordingly.
If you see something that bugs you, try taking another look after a few days.
It probably bugged me too!</p>
<p>Be patient with me.</p>
<p>If I had to guess, I'd say that YAMLScript v0 will be have a stable release
sometime before March 2024.
I'll continue blogging the progress as I go, so it shouldn't be hard for you to
decide when to start using YAMLScript for real.</p>
<p>Overall the whole thing is going extremely well, and I'm having a lot of fun.
It's important to be transparent with you about where things are at.</p>
<p>Stick with me... This is going to be awesome!</p>
<p>— Ingy döt Net</p>
</details>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Twas a Bit</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-02/"/>
      <updated>2023-12-02T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-02/</id>
      <content type="html">
        <![CDATA[
      <blockquote>
<p>'Twas a bit before Hanukkah, and all through the igloo,<br>
not a creature was stirring, not even a frog.<br>
The stockings were hung by the window with care,<br>
In hopes that St. Krampus soon would be there.<br>
The offspring were nestled all snug in their bunks,<br>
While visions of spicy-cookies danced in their heads.<br>
And cuz in their 'kerchief, and I in my bonnet,<br>
Had just settled down for a long winter's snooze.<br>
When out on the lawn there arose such a clatter,<br>
I sprang from my bench to see what was the matter.<br>
Away to the window, I flew like a jet,<br>
Tore open the shutters and threw up the curtain.<br>
The asteroid on the breast of the new-fallen frost,<br>
Gave the lustre of mid-day to dirt below.<br>
When what to my wondering eyes should materialize?<br>
But a miniature car, and eight tiny elephants.</p>
</blockquote>
<p>Well that was a bit weird.
Let's try again.
Don't worry, it's not that hard to write Winter holiday poetry when you have
YAMLScript on your side!</p>
<h3>Welcome to day 2 of YAMLScript Advent 2023!</h3>
<p>Today we're going to write a program that generates a winter holiday poem in the
Mad Libs style.
Along the way, we'll learn about several of YAMLScript's basic language
features, including:</p>
<ul>
<li>The <code>load</code> function</li>
<li>Defining functions</li>
<li>Calling functions</li>
<li>Variables</li>
<li>Random numbers</li>
<li>String interpolation</li>
</ul>
<p>So where is this awesome YAMLScript poetry generator?
Well, it's right here, of course; wrapped up in a nice little package for you to
open and enjoy!</p>
<details><summary><strong style="color:green">Open Me!!!</strong></summary>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment">#!/usr/bin/env ys-0</span><br><span class="token comment"># twas-a-bit -- Generate a winter-holiday poem in the Mad Libs style</span><br><br><span class="token key atrule">defn main()</span><span class="token punctuation">:</span><br>  <span class="token key atrule">-></span><span class="token punctuation">:</span> poem() say<br><br><span class="token key atrule">database =</span><span class="token punctuation">:</span> load("a<span class="token punctuation">-</span>bit<span class="token punctuation">-</span>of<span class="token punctuation">-</span>data.yaml")<br><br><span class="token comment"># Fetch a random word from the database:</span><br><span class="token key atrule">defn W(kind)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">rand-nth</span><span class="token punctuation">:</span> get(database<span class="token punctuation">,</span> name(kind))<br><br><span class="token key atrule">defn poem()</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string"><br>  'Twas a bit before $W(:holiday), and all through the $W(:place),<br>  not a creature was stirring, not even a $W(:animal).<br>  The stockings were hung by the $W(:hang-by) with care,<br>  In hopes that St. $W(:saint) soon would be there.<br>  The $W(:children) were nestled all snug in their $W(:beds),<br>  While visions of $W(:adj)-$W(:candies) danced in their heads.<br>  And $W(:relative) in their 'kerchief, and I in my $W(:hat),<br>  Had just settled down for a long winter's $W(:slumber).<br>  When out on the $W(:outside) there arose such a clatter,<br>  I sprang from my $W(:seat) to see what was the matter.<br>  Away to the window, I flew like a $W(:flyer),<br>  Tore open the $W(:covers) and threw up the $W(:cover).<br>  The $W(:luminary) on the breast of the new-fallen $W(:fallers),<br>  Gave the lustre of mid-day to $W(:outers) below.<br>  When what to my wondering eyes should $W(:arrive)?<br>  But a miniature $W(:vehicle), and eight tiny $W(:service-animals).</span></code></pre>
</details>
<p>You can run this program with one of the following commands:</p>
<pre class="language-bash"><code class="language-bash">$ ys twas-a-bit<br><br>$ <span class="token function">chmod</span> +x twas-a-bit <span class="token operator">&amp;&amp;</span> ./twas-a-bit</code></pre>
<p>and you'll (very likely) get a different version of the poem every time you run
it!</p>
<p>You might be wondering where all the data for this poem comes from.
I hid it in a secret place... see if you can find it!</p>
<details><summary><strong style="color:red">Don't Open Me!!!</strong></summary>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># a-bit-of-data.yaml -- Data for a-bit-before</span><br><br><span class="token key atrule">holiday</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>Christmas<span class="token punctuation">,</span> Hanukkah<span class="token punctuation">,</span> Kwanzaa<span class="token punctuation">,</span> Winter<span class="token punctuation">,</span> Solstice<span class="token punctuation">,</span> Yule<span class="token punctuation">,</span> Saturnalia<span class="token punctuation">]</span><br><span class="token key atrule">place</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>house<span class="token punctuation">,</span> apartment<span class="token punctuation">,</span> condo<span class="token punctuation">,</span> igloo<span class="token punctuation">,</span> cave<span class="token punctuation">,</span> castle<span class="token punctuation">,</span> mansion<span class="token punctuation">,</span> tent<span class="token punctuation">,</span> hut<span class="token punctuation">]</span><br><span class="token key atrule">animal</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>mouse<span class="token punctuation">,</span> cat<span class="token punctuation">,</span> dog<span class="token punctuation">,</span> bird<span class="token punctuation">,</span> fish<span class="token punctuation">,</span> snake<span class="token punctuation">,</span> lizard<span class="token punctuation">,</span> frog<span class="token punctuation">,</span> turtle<span class="token punctuation">,</span> rabbit<span class="token punctuation">]</span><br><span class="token key atrule">hang-by</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>chimney<span class="token punctuation">,</span> fireplace<span class="token punctuation">,</span> window<span class="token punctuation">,</span> toilet<span class="token punctuation">,</span> door<span class="token punctuation">,</span> wall<span class="token punctuation">,</span> faucet<span class="token punctuation">,</span> tree<span class="token punctuation">]</span><br><span class="token key atrule">saint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>Nicholas<span class="token punctuation">,</span> Claus<span class="token punctuation">,</span> Krampus<span class="token punctuation">,</span> Frost<span class="token punctuation">,</span> Jack<span class="token punctuation">,</span> Frosty<span class="token punctuation">,</span> Santa<span class="token punctuation">,</span> Bernard<span class="token punctuation">]</span><br><span class="token key atrule">children</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>children<span class="token punctuation">,</span> kids<span class="token punctuation">,</span> tots<span class="token punctuation">,</span> babies<span class="token punctuation">,</span> offspring<span class="token punctuation">,</span> spawn<span class="token punctuation">,</span> progeny<span class="token punctuation">,</span> brats<span class="token punctuation">]</span><br><span class="token key atrule">beds</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>beds<span class="token punctuation">,</span> bunks<span class="token punctuation">,</span> cots<span class="token punctuation">,</span> hammocks<span class="token punctuation">,</span> pallets<span class="token punctuation">,</span> mats<span class="token punctuation">,</span> futons<span class="token punctuation">,</span> blankets<span class="token punctuation">]</span><br><span class="token key atrule">adj</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>sweet<span class="token punctuation">,</span> sour<span class="token punctuation">,</span> salty<span class="token punctuation">,</span> bitter<span class="token punctuation">,</span> spicy<span class="token punctuation">,</span> savory<span class="token punctuation">,</span> pungent<span class="token punctuation">,</span> tart<span class="token punctuation">,</span> tangy<span class="token punctuation">]</span><br><span class="token key atrule">candies</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>candies<span class="token punctuation">,</span> chocolates<span class="token punctuation">,</span> sweets<span class="token punctuation">,</span> cookies<span class="token punctuation">,</span> cakes<span class="token punctuation">,</span> pies<span class="token punctuation">,</span> pastries<span class="token punctuation">]</span><br><span class="token key atrule">relative</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>mamma<span class="token punctuation">,</span> papa<span class="token punctuation">,</span> sis<span class="token punctuation">,</span> bro<span class="token punctuation">,</span> aunty<span class="token punctuation">,</span> uncle<span class="token punctuation">,</span> cuz<span class="token punctuation">,</span> gram<span class="token punctuation">,</span> gramps<span class="token punctuation">]</span><br><span class="token key atrule">hat</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>cap<span class="token punctuation">,</span> hat<span class="token punctuation">,</span> bonnet<span class="token punctuation">,</span> beanie<span class="token punctuation">,</span> beret<span class="token punctuation">,</span> fedora<span class="token punctuation">,</span> sombrero<span class="token punctuation">,</span> helmet<span class="token punctuation">,</span> crown<span class="token punctuation">]</span><br><span class="token key atrule">slumber</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>nap<span class="token punctuation">,</span> sleep<span class="token punctuation">,</span> slumber<span class="token punctuation">,</span> snooze<span class="token punctuation">,</span> rest<span class="token punctuation">,</span> hibernation<span class="token punctuation">,</span> siesta<span class="token punctuation">,</span> doze<span class="token punctuation">]</span><br><span class="token key atrule">outside</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>lawn<span class="token punctuation">,</span> yard<span class="token punctuation">,</span> field<span class="token punctuation">,</span> forest<span class="token punctuation">,</span> woods<span class="token punctuation">,</span> jungle<span class="token punctuation">,</span> desert<span class="token punctuation">,</span> tundra<span class="token punctuation">,</span> ocean<span class="token punctuation">]</span><br><span class="token key atrule">seat</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>bed<span class="token punctuation">,</span> chair<span class="token punctuation">,</span> couch<span class="token punctuation">,</span> sofa<span class="token punctuation">,</span> futon<span class="token punctuation">,</span> hammock<span class="token punctuation">,</span> bench<span class="token punctuation">,</span> stool<span class="token punctuation">,</span> throne<span class="token punctuation">]</span><br><span class="token key atrule">flyer</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>flash<span class="token punctuation">,</span> bolt<span class="token punctuation">,</span> bullet<span class="token punctuation">,</span> rocket<span class="token punctuation">,</span> plane<span class="token punctuation">,</span> jet<span class="token punctuation">,</span> eagle<span class="token punctuation">,</span> hawk<span class="token punctuation">,</span> falcon<span class="token punctuation">]</span><br><span class="token key atrule">covers</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>shutters<span class="token punctuation">,</span> blinds<span class="token punctuation">,</span> curtains<span class="token punctuation">,</span> shades<span class="token punctuation">,</span> drapes<span class="token punctuation">,</span> screens<span class="token punctuation">,</span> panels<span class="token punctuation">]</span><br><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>shutter<span class="token punctuation">,</span> blind<span class="token punctuation">,</span> curtain<span class="token punctuation">,</span> shade<span class="token punctuation">,</span> drape<span class="token punctuation">,</span> screen<span class="token punctuation">,</span> panel<span class="token punctuation">]</span><br><span class="token key atrule">luminary</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>moon<span class="token punctuation">,</span> sun<span class="token punctuation">,</span> star<span class="token punctuation">,</span> planet<span class="token punctuation">,</span> comet<span class="token punctuation">,</span> asteroid<span class="token punctuation">,</span> meteor<span class="token punctuation">,</span> satellite<span class="token punctuation">]</span><br><span class="token key atrule">fallers</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>snow<span class="token punctuation">,</span> rain<span class="token punctuation">,</span> hail<span class="token punctuation">,</span> sleet<span class="token punctuation">,</span> ice<span class="token punctuation">,</span> slush<span class="token punctuation">,</span> frost<span class="token punctuation">,</span> dew<span class="token punctuation">,</span> fog<span class="token punctuation">,</span> mist<span class="token punctuation">]</span><br><span class="token key atrule">outers</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>trees<span class="token punctuation">,</span> bushes<span class="token punctuation">,</span> shrubs<span class="token punctuation">,</span> flowers<span class="token punctuation">,</span> grass<span class="token punctuation">,</span> weeds<span class="token punctuation">,</span> rocks<span class="token punctuation">,</span> dirt<span class="token punctuation">,</span> sand<span class="token punctuation">]</span><br><span class="token key atrule">arrive</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>appear<span class="token punctuation">,</span> arrive<span class="token punctuation">,</span> come<span class="token punctuation">,</span> materialize<span class="token punctuation">,</span> manifest<span class="token punctuation">,</span> show up<span class="token punctuation">,</span> land<span class="token punctuation">]</span><br><span class="token key atrule">vehicle</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>sleigh<span class="token punctuation">,</span> car<span class="token punctuation">,</span> truck<span class="token punctuation">,</span> van<span class="token punctuation">,</span> bus<span class="token punctuation">,</span> train<span class="token punctuation">,</span> plane<span class="token punctuation">,</span> boat<span class="token punctuation">,</span> ship<span class="token punctuation">,</span> rocket<span class="token punctuation">]</span><br><span class="token key atrule">service-animals</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>reindeer<span class="token punctuation">,</span> horses<span class="token punctuation">,</span> camels<span class="token punctuation">,</span> elephants<span class="token punctuation">,</span> oxen<span class="token punctuation">,</span> donkeys<span class="token punctuation">,</span> mules<span class="token punctuation">]</span></code></pre>
</details>
<h3>The <code>load</code> Function</h3>
<p>If you found the secret database you can see that it's just a YAML file.
Our YAMLScript program loads this file using the <code>load</code> function.
The <code>load</code> function is one of the most important functions in YAMLScript.
It reads a YAMLScript file, evaluates it, and returns the result.</p>
<p>But we loaded a YAML file, not a YAMLScript file.
How did that work?
Remember that (almost) every YAML file is a valid YAMLScript program, so it just
works.</p>
<p>We can also use it to load a JSON data file.
Why?
Because JSON is a subset of YAML.
That means that (absolutely) every JSON file is a valid YAML file, and therefore
every JSON file is a valid YAMLScript program!</p>
<p>The <code>load</code> function is just one of literally hundreds of core functions
available to you by default in YAMLScript.
It's part of the YAMLScript standard library.
These functions give you the ability to code anything possible in any modern
programming language.
We'll be learning more about them in the coming days.</p>
<h3>Defining Functions</h3>
<p>We defined 3 functions in our poem generator: <code>main</code>, <code>W</code>, and <code>poem</code>.
We did this using <code>defn</code>, which is short for &quot;define function&quot;.</p>
<p>Here's a simple function that tells you how far away you are from the answer to
life, the universe, and everything:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">defn how-far-away(n)</span><span class="token punctuation">:</span> abs(42 <span class="token punctuation">-</span> n)</code></pre>
<p>In YAML terms this is a mapping pair whose key is a plain (unquoted) string
containing <code>defn</code>, the function name, and the function parameters.
The mapping pair's value is the function body, which is a YAMLScript expression.</p>
<p>A YAMLScript function returns the value of its last evaluated expression.</p>
<h3>Calling Functions</h3>
<p>There are a lot of ways to call a function in YAMLScript.
In fact, there are a lot of ways to do almost everything in YAMLScript.
The only hard and fast rule is that the entire program must be valid YAML.</p>
<p>Consider this expression:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">map inc</span><span class="token punctuation">:</span> range(1<span class="token punctuation">,</span> 10)</code></pre>
<p>Here we are calling 2 functions: <code>map</code> and <code>range</code>.
Another way to write this would be:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">map inc</span><span class="token punctuation">:</span><br>  <span class="token key atrule">range</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span></code></pre>
<p>or:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">=></span><span class="token punctuation">:</span> map(inc<span class="token punctuation">,</span> range(1<span class="token punctuation">,</span> 10))</code></pre>
<p>or:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">-></span><span class="token punctuation">:</span> range(1<span class="token punctuation">,</span> 10)<span class="token punctuation">,</span> map(inc)</code></pre>
<p>There's actually many more ways to write this, but this is only day 2 of
YAMLScript Advent 2023, so we'll save those for later.</p>
<p>In general, these 2 forms are equivalent:</p>
<pre class="language-yaml"><code class="language-yaml">a b<span class="token punctuation">,</span> <span class="token key atrule">c</span><span class="token punctuation">:</span> d<span class="token punctuation">,</span> e<span class="token punctuation">,</span> f<br><span class="token punctuation">---</span><br>a(b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> e<span class="token punctuation">,</span> f)</code></pre>
<p>In YAMLScript, a function call is either a mapping pair or a scalar.
When it is a mapping pair, the key and the value can both have 1 or more
expressions.
The first expression on the key side is the function name and all the rest of
the expressions on both sides are the function arguments.
When it is a scalar, a function name is followed by a parenthesized list of
arguments.
Note that the opening parenthesis must immediately follow the function name
without any intervening whitespace.</p>
<p>You may have noticed a few more functions just now: <code>inc</code>, <code>=&gt;</code>, and <code>-&gt;</code>.
Well, <code>inc</code> is a function but we didn't call it directly.
We passed it as an argument to the <code>map</code> function.</p>
<p>I'll tell you about <code>=&gt;</code> and <code>-&gt;</code> later.</p>
<blockquote>
<h3>Comma Chameleon</h3>
<p>I was going to save this for later, but I just can't wait...</p>
<p><strong>Commas are a Lie!</strong></p>
<p>In YAMLScript, commas are optional whitespace.
You can use them to make your code more readable, if that's your thing.
It's not my thing, so I won't use them much from here on out.</p>
</blockquote>
<h3>Variables</h3>
<p>One of my favorite things about YAMLScript is that you can use any word as a
variable or function name.
We call these names &quot;symbols&quot;.</p>
<p>For example almost every language has an <code>if</code> keyword, and (since it is a
special keyword) you can't use it for a name.
In YAMLScript you are free to use the <code>if</code> symbol (as a variable or function
name) as long as you don't need to use the standard <code>if</code> function in the same
scope.</p>
<p>We assign a value to a variable like so:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">foo =</span><span class="token punctuation">:</span> <span class="token number">42</span></code></pre>
<p>This is a mapping pair whose key is a plain string containing the variable name
followed by <code>=:</code> separated by at least one space character.
The pair value is the assignment value.
Simple!</p>
<h3>Strings</h3>
<p>If you know your YAML, you know that YAML has 5 different styles to represent
a scalar value (a string, number, boolean, etc).
The styles are called &quot;plain&quot; (unquoted), &quot;single-quoted&quot;, &quot;double-quoted&quot;,
&quot;literal&quot;, and &quot;folded&quot;.
Plain scalar turns strings, numbers, booleans, etc.
The other 4 styles are always strings.</p>
<p>In YAMLScript code, the scalar style is very important.
Symbols and expressions are always plain scalars.
The 4 other styles are used for strings.</p>
<h3>Random Numbers</h3>
<p>We used the <code>rand-nth</code> function to select a random value from a list.
Not much to say about that, except that it's a function that takes a list as an
argument and returns a random value from it.</p>
<h3>String Interpolation</h3>
<p>YAMLScript strings written in the &quot;single-quoted&quot; or &quot;folded&quot; styles are just
strings, but when you use the &quot;double-quoted&quot; or &quot;literal&quot; styles, the strings
have interpolation super powers!</p>
<p>Interpolation is the process of inserting the value of variables or expressions
into a string in the place where they appear.
In YAMLScript, these expanding objects are indicated by a <code>$</code> character
immediately followed by the variable or expression.</p>
<p>This is pretty much the same as string interpolation in a shell like Bash:</p>
<pre class="language-bash"><code class="language-bash"><span class="token assign-left variable">name</span><span class="token operator">=</span>World<br><span class="token builtin class-name">echo</span> <span class="token string">"Hello <span class="token variable">$name</span>. The answer is <span class="token variable"><span class="token variable">$((</span><span class="token number">43</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token variable">))</span></span>."</span></code></pre>
<p>The equivalent YAMLScript code would be:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">name =</span><span class="token punctuation">:</span> <span class="token string">"World"</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"Hello $name. The answer is $(43 - 1)."</span></code></pre>
<p>You can also interpolate a YAMLScript function call (symbol followed by argument
list) like this:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"Hello $inc(41)."</span></code></pre>
<p>In most langauages that support interpolation <code>inc</code> would expand as a variable,
but in YAMLScript it's a function and the parenthesized argument list is part of
the expression.</p>
<p>This is the kind of interpolation syntax we used in our poem generator program.</p>
<h3>Conclusion</h3>
<p>Well that wraps up day 2 of the YAMLScript Advent 2023.
I hope you enjoyed it, and learned a bit more about YAMLScript.</p>
<p>Honestly, at this point you probaby have more questions than answers.
Luckily for you, December has more than 2 days in it.
See you tomorrow!</p>
<p>I'll leave you with a little poem that a close friend of mine just wrote:</p>
<blockquote>
<p>'Twas a bit before Winter, and all through the hut,<br>
not a creature was stirring, not even a snake.<br>
The stockings were hung by the faucet with care,<br>
In hopes that St. Frosty soon would be there.<br>
The tots were nestled all snug in their bunks,<br>
While visions of pungent-candies danced in their heads.<br>
And uncle in their 'kerchief, and I in my fedora,<br>
Had just settled down for a long winter's rest.<br>
When out on the lawn there arose such a clatter,<br>
I sprang from my sofa to see what was the matter.<br>
Away to the window, I flew like a bullet,<br>
Tore open the panels and threw up the blind.<br>
The planet on the breast of the new-fallen snow,<br>
Gave the lustre of mid-day to flowers below.<br>
When what to my wondering eyes should materialize?<br>
But a miniature train, and eight tiny oxen.</p>
</blockquote>
<p>&nbsp;</p>
<details><summary style="color:#888">Santa's little secrets...</summary>
<p>In December 2023 YAMLScript is a work in progress.</p>
<p>This is not to say that it's vaporware, or a toy proof of concept.
It has a working compiler, runtime and CLI.
It has unit tests that must pass for every commit pushed to the main branch.
It's well thought out and has a clear direction that I continually vet with a
small group of talented and trusted people.</p>
<p>But that in turn not to say that you should use it in production today.
I encourage you to start playing with it, and I'm committed to backwards
compatibility for stable releases.
But we're not quite there yet.
Caveat usor!</p>
<p>YAMLScript is evolving fast.
While I'm writing these posts, I'm also writing the code for new features and
fixing bugs as I go.
I've had the Advent plan for over a month now, and I had planned to be further
along before December 1st, but such are the time estimates of hackers.</p>
<p>I am attempting to make sure that the code examples in these posts are always
using the implemented features, but sometimes I may fall a few hours behind.
Often I need to write the examples using code patterns that actually work but
are not the ones I preferred to best make a point.</p>
<p>As I fix bugs, implement features and tweak the language, I will update the
posts accordingly.
If you see something that bugs you, try taking another look after a few days.
It probably bugged me too!</p>
<p>Be patient with me.</p>
<p>If I had to guess, I'd say that YAMLScript v0 will be have a stable release
sometime before March 2024.
I'll continue blogging the progress as I go, so it shouldn't be hard for you to
decide when to start using YAMLScript for real.</p>
<p>Overall the whole thing is going extremely well, and I'm having a lot of fun.
It's important to be transparent with you about where things are at.</p>
<p>Stick with me... This is going to be awesome!</p>
<p>— Ingy döt Net</p>
</details>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Load em Up!</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-03/"/>
      <updated>2023-12-03T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-03/</id>
      <content type="html">
        <![CDATA[
      <blockquote>
<p>On the 3rd day of Advent, my YS gave to me...<br>
A sequence in a map tree!</p>
</blockquote>
<p>Did you know that all JSON <em>is</em> YAML?
You should, because I told you that <a href="/posts/advent-2023/dec-02/">yesterday</a>!</p>
<p>It's true.
YAML is a superset of JSON.
Both in terms of syntax and data model.</p>
<p>This means that any possible valid JSON input is also valid as a YAML input.
A proper YAML loader and a JSON loader should produce the same data structure
from the same JSON input.</p>
<blockquote>
<p>Assuming a YAML 1.2 loader using the YAML 1.2 JSON Schema</p>
</blockquote>
<h3>Welcome to day 3 of YAMLScript Advent 2023!</h3>
<p>This YAML/JSON relationship has some interesting implications for people
interacting with systems that read YAML or JSON as input.</p>
<p>People often prefer to read or write data in YAML because it's more
human-friendly with its structured indentation, lack of excessive punctuation
and its support for comments.
JSON is more machine-friendly due to its simplicity and robust tooling, thus
often prererable for machine-to-machine communication.</p>
<p>It's quite common to see people configure their systems that have JSON inputs by
using YAML instead, and setting things up to convert the hand maintained YAML to
JSON before the system sees it.
It can also be helpful to format large JSON API responses as YAML so that they
are easier to read.</p>
<p>Going the other way, people can refactor large YAML configurations by first
converting them to JSON, using JSON tools like <code>jq</code> to manipulate the data and
then converting the data back to YAML.</p>
<p>YAMLScript is an ideal technology for performing these kinds of conversions and
manipulations.</p>
<h3>Loading vs Running YAMLScript</h3>
<p>On one hand, YAMLScript is a complete programming language that you can use for
writing new applications (and libraries).
In YAMLScript jargon, we &quot;run&quot; these applications.
We'll discuss YAMLScript apps and &quot;running&quot; them extensively in the coming days.</p>
<p>Today we are covering YAMLScript's purpose we just described: reading YAML
files into data; possibly transforming the data dynamically along the way.</p>
<p>This use of YAMLScript is called &quot;loading&quot; and can be done on most existing YAML
files and all existing JSON files.</p>
<details><summary>What does "most" mean?</summary>
<p>When I say &quot;most YAML input files&quot; I mean YAML input that fits into the JSON
data model.
Almost all YAML files used for configuration purposes fall into this category.</p>
<p>Specifically:</p>
<ul>
<li>Mapping keys must be strings.</li>
<li>Aliases may not create circular references.</li>
<li>Custom tags (those beyond the YAML 1.2 JSON Schema) must not be used.</li>
</ul>
<p>I've never seen any of those things used in a configuration file.</p>
<hr>
</details>
<p>Let's look at an example.</p>
<p>YAML uses the term &quot;load&quot; to refer to the process of a computer program
converting a YAML text into a data structure in memory.
It is common for a YAML framework to have a <code>load</code> (and <code>dump</code>) function or
method as its primary API.</p>
<p>Here's a Python single line program that loads a YAML text into a Python
dictionary and and then prints it.</p>
<pre class="language-bash"><code class="language-bash">$ python <span class="token parameter variable">-c</span> <span class="token string">'import yaml; print(yaml.safe_load("Advent day: 3"))'</span><br><span class="token punctuation">{</span><span class="token string">'Advent day'</span><span class="token builtin class-name">:</span> <span class="token number">3</span><span class="token punctuation">}</span></code></pre>
<p>YAMLScript will soon offer a binding in your favorite language that will do the
same thing:</p>
<pre class="language-bash"><code class="language-bash">$ python <span class="token parameter variable">-c</span> <span class="token string">'import yamlscript; print(yamlscript.load("Advent day: 3"))'</span><br><span class="token punctuation">{</span><span class="token string">'Advent day'</span><span class="token builtin class-name">:</span> <span class="token number">3</span><span class="token punctuation">}</span></code></pre>
<p>A major goal of the YAMLScript project is to have these YAMLScript binding
libraries be the best way to load YAML config files in all modern programming
languages.
This will be a big improvement over the current situation where every YAML
framework has its own API and its own set of bugs and quirks.</p>
<h3>Loading YAMLScript from the Command Line</h3>
<p>The Python and other language bindings are not ready yet, but we can still load
YAMLScript.
We can do it from the command line using the <code>ys</code> command with the <code>--load</code>
option.</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-le</span> <span class="token string">'Advent day: 3'</span><br><span class="token punctuation">{</span><span class="token string">"Advent day"</span><span class="token builtin class-name">:</span> <span class="token number">3</span><span class="token punctuation">}</span></code></pre>
<blockquote>
<p>Note: The <code>-le</code> option is a short for <code>-l</code> (short for <code>--load</code>) and <code>-e</code>.</p>
</blockquote>
<p>Since the command line doesn't have any way to store the loaded YAML (like a
programming language would as a data structure) we have to get it back as text.
By default, <code>ys</code> prints the loaded YAML as JSON.</p>
<p>That may seem strange; a YAML loader defaulting to JSON.
But it's not strange at all, for two reasons:</p>
<ul>
<li>JSON <em>is</em> YAML. Remember?!</li>
<li>JSON is the de facto Lingua Franca of inter-program communication.</li>
</ul>
<p>Put another way, <code>ys</code> outputs YAML in its most compatible format.</p>
<p>In a programming language, we load YAML data into an object and pass it to some
function to do something with it.
In the CLI-as-programming-language analogy, the functions are other programs!</p>
<h3>Loading YAML Dynamically</h3>
<p>The main point of today's post is to show how YAMLScript can be used as a normal
YAML loader.
But of course, YS has SuperPowers™ that other YAML loaders don't have.</p>
<blockquote>
<p>NOTE: From now on I will sometimes use &quot;YS&quot; as shorthand for &quot;YAMLScript&quot;.
This is distinct from <code>ys</code> which is the command-line tool that runs/loads YS.</p>
</blockquote>
<p>With great SuperPowers comes SuperResponsibility.
YS won't use its SuperPowers unless you ask it to.
You may ask it (politely) in one of these ways:</p>
<ul>
<li>Start the YS with the <code>!yamlscript/v0</code> tag
<ul>
<li>Words are commands by default</li>
</ul>
</li>
<li>Start the YS with the <code>!yamlscript/v0/data</code> tag
<ul>
<li>Words are data by default</li>
</ul>
</li>
<li>Use a <code>ys-0</code> shebang line like: <code>#!/usr/bin/env ys-0</code>
<ul>
<li>Implicitly defaults to <code>!yamlscript/v0</code></li>
</ul>
</li>
<li>Use the <code>-e</code> option for YS one-liners
<ul>
<li>Imlicitly defaults to <code>!yamlscript/v0</code> (for one-liner convenience)</li>
</ul>
</li>
</ul>
<p>After that you are good to go!</p>
<p>Imagine we have YAML files containing top level mappings such as:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># map1.yaml</span><br><span class="token key atrule">reindeer</span><span class="token punctuation">:</span><br><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Dancer<br><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Blitzen<br><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Rudolph<br>  <span class="token key atrule">nosy</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre>
<p>We can pull data from these files into our YAML dynamically:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># file1.ys</span><br><span class="token tag">!yamlscript/v0/data</span><br><br><span class="token key atrule">key1</span><span class="token punctuation">:</span> val1<br><span class="token key atrule">key2</span><span class="token punctuation">:</span> <span class="token tag">!</span> load("map1.yaml")<br><span class="token key atrule">key3</span><span class="token punctuation">:</span> val3</code></pre>
<p>Now if we &quot;ran&quot; the YS nothing would happen, but when we &quot;load&quot; it, we get the
data we expect.</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">--load</span> file1.ys<br><span class="token punctuation">{</span><span class="token string">"key1"</span><span class="token builtin class-name">:</span> <span class="token string">"val1"</span>, <span class="token string">"key2"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span><span class="token string">"reindeer"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token builtin class-name">:</span> <span class="token string">"Dancer"</span><span class="token punctuation">}</span>, <span class="token punctuation">{</span><span class="token string">"name"</span><span class="token builtin class-name">:</span> <span class="token string">"Blitzen"</span><span class="token punctuation">}</span>, <span class="token punctuation">{</span><span class="token string">"name"</span><span class="token builtin class-name">:</span> <span class="token string">"Rudolph"</span>, <span class="token string">"nosy"</span><span class="token builtin class-name">:</span> true<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span>, <span class="token string">"key3"</span><span class="token builtin class-name">:</span> <span class="token string">"val3"</span><span class="token punctuation">}</span></code></pre>
<p>Now I can explain those pesky YAML tags!
What does this YS mapping pair mean?</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token number">123</span></code></pre>
<p>Well, it depends.
It could be a command to print the number 123 as text to the console.
Or it could be a mapping pair with the key <code>say</code> and the value <code>123</code>.
The starting tag tells us which it is.
The <code>!yamlscript/v0</code> tag means that we start off things in a state where plain
(unquoted) YAML scalars are code.
OTOH, with <code>!yamlscript/v0/data</code> these scalars are data like in normal YAML.</p>
<p>The <code>!</code> tag is how we switch back and forth (toggle) between these two states.
If you have existing YAML files and you want to use a couple of YS functions in
them, start them with <code>!yamlscript/v0/data</code> and then use <code>!</code> tags before the
functional parts.</p>
<p>Another way to accomplish the same result is:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># file2.ys</span><br><span class="token tag">!yamlscript/v0</span><br><br><span class="token key atrule">map1 =</span><span class="token punctuation">:</span> load("map1.yaml")<br><br><span class="token key atrule">=></span><span class="token punctuation">:</span><br>  .<span class="token punctuation">{</span><br>    <span class="token punctuation">:</span>key1 "val1"<br>    <span class="token punctuation">:</span>key2 map1<br>    <span class="token punctuation">:</span>key3 "val3"<br>  <span class="token punctuation">}</span></code></pre>
<p>Here everything is code, and the final expression is the data we want to load.
When you run <code>ys --load file2.ys</code> you get the same result as before.</p>
<blockquote>
<p>Note: The things starting with <code>:</code> are called keywords, and they turn into one
word strings on output.
More on keywords another day.</p>
</blockquote>
<h3>Merging Mappings and Joining Sequences</h3>
<p>I'll leave you with the two most frequent requests that Santa gets from YAML
kids: <code>merge</code> and <code>concat</code>.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># file3.ys</span><br><span class="token tag">!yamlscript/v0/data</span><br><br><span class="token key atrule">my-map</span><span class="token punctuation">:</span> <span class="token tag">!</span><br>  <span class="token key atrule">merge</span><span class="token punctuation">:</span><br>    load("map1.yaml")<br>    load("map2.yaml")<br><span class="token key atrule">my-seq</span><span class="token punctuation">:</span> <span class="token tag">!</span><br>  <span class="token key atrule">concat</span><span class="token punctuation">:</span><br>    load("seq1.yaml")<br>    load("seq2.yaml")</code></pre>
<p>When we were inventing YAML 20 years ago, one of the most confusing things we
did was to suggest that <code>&lt;&lt;</code> used as a key could trigger a merge operation.</p>
<p>It wasn't a good idea because:</p>
<ul>
<li>It's the only dynamic thing we put in YAML</li>
<li>It actually wasn't in the spec proper</li>
<li>It's not well defined at all</li>
<li>Many YAML frameworks don't support it at all</li>
<li>The ones that do it, all do it differently</li>
</ul>
<p>But people love it, and they want more!</p>
<p>Well... YS gives you more.
100s more (standard functions) in fact!
(All in good time, my patient Advent-urers.)</p>
<p>Let's end this day by making that last YS file even cooler than Rudolph's toes!</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0/data</span><br><br><span class="token key atrule">my-map</span><span class="token punctuation">:</span> <span class="token tag">!</span> load("map1.yaml") + load("map2.yaml")<br><span class="token key atrule">my-seq</span><span class="token punctuation">:</span> <span class="token tag">!</span> load("seq1.yaml") + load("seq2.yaml")</code></pre>
<p>YAMLScript's <code>+</code> operator is a general purpose joiner.
It's polymorphic for numbers, strings, sequences and mappings.</p>
<p>As ususal, I hope you enjoyed today's post.
I'll see you tomorrow for day 4 of YAMLScript Advent 2023!</p>
<!--
refactor this into a template and include it.
https://github.com/11ty/eleventy/issues/658#issuecomment-599142642
-->
<p>&nbsp;</p>
<details><summary style="color:#888">Santa's little secrets...</summary>
<p>In December 2023 YAMLScript is a work in progress.</p>
<p>This is not to say that it's vaporware, or a toy proof of concept.
It has a working compiler, runtime and CLI.
It has unit tests that must pass for every commit pushed to the main branch.
It's well thought out and has a clear direction that I continually vet with a
small group of talented and trusted people.</p>
<p>But that in turn not to say that you should use it in production today.
I encourage you to start playing with it, and I'm committed to backwards
compatibility for stable releases.
But we're not quite there yet.
Caveat usor!</p>
<p>YAMLScript is evolving fast.
While I'm writing these posts, I'm also writing the code for new features and
fixing bugs as I go.
I've had the Advent plan for over a month now, and I had planned to be further
along before December 1st, but such are the time estimates of hackers.</p>
<p>I am attempting to make sure that the code examples in these posts are always
using the implemented features, but sometimes I may fall a few hours behind.
Often I need to write the examples using code patterns that actually work but
are not the ones I preferred to best make a point.</p>
<p>As I fix bugs, implement features and tweak the language, I will update the
posts accordingly.
If you see something that bugs you, try taking another look after a few days.
It probably bugged me too!</p>
<p>Be patient with me.</p>
<p>If I had to guess, I'd say that YAMLScript v0 will be have a stable release
sometime before March 2024.
I'll continue blogging the progress as I go, so it shouldn't be hard for you to
decide when to start using YAMLScript for real.</p>
<p>Overall the whole thing is going extremely well, and I'm having a lot of fun.
It's important to be transparent with you about where things are at.</p>
<p>Stick with me... This is going to be awesome!</p>
<p>— Ingy döt Net</p>
</details>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Santa&#39;s Big Secret</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-04/"/>
      <updated>2023-12-04T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-04/</id>
      <content type="html">
        <![CDATA[
      <p>I've got a little secret to tell you.
I've been hiding a little something from you.
Even that's a lie.
I've actually been hiding something very very big something from you.</p>
<blockquote>
<h3>*** YAMLScript is a Lisp! *****</h3>
</blockquote>
<h3>Welcome to day 4 of YAMLScript Advent 2023!</h3>
<p>Today is Monday and Monday's are made for big headlines.</p>
<p>That's right.
Not only is YAMLScript a Lisp, it's a very specifig and modern Lisp.
It's a Lisp that has a community and conferences and books and jobs and that pay
people to write code in Lisp!</p>
<p>If you know the slightest thing about Lisp, you must think I'm crazy.
YAMLScript is YAML, and YAML is no Lisp.
It's almost the Anti-Lisp incarnate.</p>
<p>OK. Here's the deal...</p>
<blockquote>
<h3>YAMLScript <em>is</em> Clojure</h3>
</blockquote>
<p>There you go. The secret is out.
Every YAMLScript program is program is a Clojure program.</p>
<p>Every time you run (or load!) a YAMLScript program, it compiles to Clojure code
that is then run by a Clojure runtime engine.
I can prove it!</p>
<p>Consider this YAMLScript program:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># hw.ys</span><br><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">println</span><span class="token punctuation">:</span> <span class="token string">"Hello, world!"</span></code></pre>
<p>Let's run it:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">--run</span> hw.ys<br>Hello, world<span class="token operator">!</span></code></pre>
<p>No surprises there.
Now let's first compile it to Clojure:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">--compile</span> hw.ys<br><span class="token punctuation">(</span>println <span class="token string">"Hello, world!"</span><span class="token punctuation">)</span></code></pre>
<p>Looks pretty Lispy to me.
Now let's run the Clojure code:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-c</span> hw.ys <span class="token operator">|</span> clojure -<br>Hello, world<span class="token operator">!</span></code></pre>
<p>It works!
YAMLScript really <em>is</em> Clojure.
And Clojure most definitely <em>is</em> a Lisp.
Soooooo...?!
Yeah, you get it. QED, baby!</p>
<h3>What is Clojure?</h3>
<p>Oh wait, you don't know what Clojure is?
Or maybe you need a quick refresher?</p>
<p>Clojure is a modern Lisp that runs on the JVM.
It was created by this really intersting guy named <a href="https://en.wikipedia.org/wiki/Rich_Hickey">Rich Hickey</a> whom I've actually met many times...</p>
<p>...on YouTube.</p>
<p>I don't typically watch a lot of programming videos, but I've seen at least a
dozen of his.
I encourage you to watch some too.
Or at least peruse some of his <a href="https://gist.github.com/reborg/dc8b0c96c397a56668905e2767fd697f">various opinions on varying programming topics</a></p>
<p>Rich programmed professionally in Java for many years.
One day he decided that he couldn't take it anymore.
He took a couple years off and he changed the world.
The Java world anyway.</p>
<p>Java is a widely used imperative programming language, with mutable data
structures and a noisy syntax.
Clojure by contrast is a functional programming language, with immutable data
structures and a very clean syntax.
You can use any Java library directly from Clojure and vice versa, making
Clojure an extremely practical language.</p>
<p>In a phrase: <strong>&quot;Clojure makes Java not suck&quot;</strong>. (Ingy's words, not Rich's)</p>
<h3>What does this all have to say about YAMLScript?</h3>
<p><strong>Yesterday we learned that all JSON is YAML and that almost all YAML is
YAMLScript.
Does this means that all JSON is Clojure?</strong></p>
<p>Actually it kind of does.</p>
<p>Let's compile some JSON with <code>ys</code>:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-md</span> <span class="token parameter variable">-ce</span> <span class="token string">'{ "foo": "bar", "baz": [1, 2, null, true] }'</span><br><span class="token punctuation">{</span><span class="token string">"foo"</span> <span class="token string">"bar"</span>, <span class="token string">"baz"</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> nil true<span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre>
<p>Yep. That's Clojure.
It also happens to be EDN, which is Clojure's native data format.</p>
<blockquote>
<p>Note: The <code>-md</code> option tells <code>ys</code> not to add the <code>!yamlscript/v0</code> tag that it
usually does with <code>-e</code> to make your YS life easier.
We'll learn more about <code>-m</code> another time.</p>
</blockquote>
<p><strong>Lisp puts parentheses around everything.
Does that mean that YAMLScript does too?</strong></p>
<p>Good question. Tha answer may surprise you.
YAMLScript has a lot of different ways to express code.
It embraces diversity. (As long as that diversity can be written as YAML!)
One of the ways to write code in YAMLScript is in Clojure syntax!</p>
<p>This YAMLScript prints 3 symbol names available in the current namespace:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-e</span> <span class="token string">'(say (take (+ 1 2) (keys (ns-map *ns*))))'</span><br><span class="token punctuation">(</span>+' decimal? sort-by<span class="token punctuation">)</span></code></pre>
<p>In Lisp every expression (function call) is a paranthesized list where the first
word is the function name and the rest are the arguments.
That means arithmetic expressions like <code>1 + 2</code> are written as <code>(+ 1 2)</code>.</p>
<p>This feels very natural to Lisp programmers, but it can be a bit of a shock to
the rest of us.
YAMLScript offers alternate ways (called ysexprs or YeS Expressions) to write
these Lisp basic forms.</p>
<p>We'll learn the gritty details in another post, but here's the basics:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">=></span><span class="token punctuation">:</span> 1 + 2               <span class="token comment"># (+ 1 2)   ;; + - * /</span><br><span class="token key atrule">=></span><span class="token punctuation">:</span> 3 * 4 * 5           <span class="token comment"># (* 3 4 5) ;; if operators are the same</span><br><span class="token key atrule">=></span><span class="token punctuation">:</span> foo(bar(42 true))   <span class="token comment"># (foo (bar 42 true))</span></code></pre>
<p>We could write the above YAMLScript expression like this:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">say</span><span class="token punctuation">:</span><br>  <span class="token key atrule">take (+</span><span class="token punctuation">:</span> <span class="token key atrule">1 2)</span><span class="token punctuation">:</span><br>    <span class="token key atrule">keys</span><span class="token punctuation">:</span> ns<span class="token punctuation">-</span>map(<span class="token important">*ns*)</span></code></pre>
<p>Both YAMLScript forms compile to the same Clojure code.</p>
<p>Basically at any level of YAML in YAMLScript, you can switch to using Clojure.
Since an entire YAML document can be a single string you can sometimes use an
entire Clojure file as a YAMLScript program.
As long as it's valid YAML, of course.</p>
<p><strong>Clojure is a JVM Language.
Does that mean that YAMLScript is a JVM language?</strong></p>
<p>This one is crazy.
YAMLScript does not need the JVM or anything Java whatsoever.
The <code>ys</code> binary is a native machine code executable.
The <code>libyamlscript</code> shared library is also native machine code and thus can be
FFI bound to almost any programming language.</p>
<p>You don't even need to have Java installed on your system to <em>build</em> YAMLScript.
That's a little fib.
The build system always downloads a Java build system and then discards it when
it's done.
The point is that to build <code>ys</code> you don't need to set up any prerequisites.
It just works.</p>
<p>How is this possible?
It's all thanks to <a href="https://www.graalvm.org/">GraalVM</a> which is, as one of my YS
friends puts it, &quot;a cheat code&quot;!
GraalVM's <code>native-image</code> compiler can magically turn anything Java into native
machine code on Linux, macOS and Windows.
<strong>Wow!</strong></p>
<p>A very noticeable difference between YAMLScript and Clojure is startup time:</p>
<pre class="language-bash"><code class="language-bash">$ <span class="token function">time</span> ys <span class="token parameter variable">-e</span> <span class="token number">1</span><br>real    0m0.044s<br>$ <span class="token function">time</span> perl <span class="token parameter variable">-e</span> <span class="token number">1</span>    <span class="token comment"># for comparison</span><br>real    0m0.048s<br>$ <span class="token function">time</span> clojure <span class="token parameter variable">-M</span> <span class="token parameter variable">-e</span> <span class="token number">1</span><br><span class="token number">1</span><br>real    0m0.637s</code></pre>
<p>Clojure's not 10 times slower than YS (or Perl).
It just takes 10 times longer to start up a JVM.</p>
<p><strong>Do you need to know Clojure to use YAMLScript?</strong></p>
<p>No, not at first.
Proof?
I just got through 3 days of YAMLScript Advent without mentioning Clojure once.</p>
<p>If you just want to make your out of control YAML files more manageable,
composable and maintainable, you can easily learn how to wield YAMLScript
without knowing a lick of Clojure.</p>
<p>When you need more power it's there for you because Clojure is there for you.
But you have to learn some new things first.</p>
<p>I honestly think YS can be a great introduction to Clojure.
I think that Clojure is a great introduction to Lisp, working with immutable
data structures, and functional programming.
And I think that learning these things will make you a better programmer in
whatever language you use.</p>
<p>YAML has always been about making things easier in all programming languages.
My love for Clojure is that it has the right parts to make YAML more powerful
in all those same languages.
I have no desire to see the whole world switch to Clojure (or anything else).
Clojure is a great gift and I hope YS can help more people benefit from it in
the langauges and technologies they already use.</p>
<p><strong>How does YAMLScript benefit from building over Clojure?</strong></p>
<p>In a nutshell, it makes YAMLScript a complete, robust, battle tested, and
well-documented language from the get go.
Rich knew that to make a new language in 2006 he needed to build on something
that was already a big deal; the Java ecosystem.</p>
<p>I feel the exact same way about YAMLScript.</p>
<p>YAMLScript is poised to take YAML to a whole new level.
This is all thanks to the shoulders of these specific giants:</p>
<ul>
<li><a href="https://yaml.org/">YAML</a></li>
<li><a href="https://clojure.org/">Clojure</a></li>
<li><a href="https://bitbucket.org/asomov/snakeyaml/src/master/">SnakeYAML</a></li>
<li><a href="https://github.com/babashka/sci">Small Clojure Interpreter (SCI)</a></li>
<li><a href="https://www.graalvm.org/">GraalVM</a></li>
</ul>
<p>I'll have more to say about each of these in future posts.
For now, I'll just say that I'm extremely grateful for all of them.</p>
<p>I'll see you tomorrow for day 5 of YAMLScript Advent 2023!</p>
<p>&nbsp;</p>
<details><summary style="color:#888">Santa's little secrets...</summary>
<p>In December 2023 YAMLScript is a work in progress.</p>
<p>This is not to say that it's vaporware, or a toy proof of concept.
It has a working compiler, runtime and CLI.
It has unit tests that must pass for every commit pushed to the main branch.
It's well thought out and has a clear direction that I continually vet with a
small group of talented and trusted people.</p>
<p>But that in turn not to say that you should use it in production today.
I encourage you to start playing with it, and I'm committed to backwards
compatibility for stable releases.
But we're not quite there yet.
Caveat usor!</p>
<p>YAMLScript is evolving fast.
While I'm writing these posts, I'm also writing the code for new features and
fixing bugs as I go.
I've had the Advent plan for over a month now, and I had planned to be further
along before December 1st, but such are the time estimates of hackers.</p>
<p>I am attempting to make sure that the code examples in these posts are always
using the implemented features, but sometimes I may fall a few hours behind.
Often I need to write the examples using code patterns that actually work but
are not the ones I preferred to best make a point.</p>
<p>As I fix bugs, implement features and tweak the language, I will update the
posts accordingly.
If you see something that bugs you, try taking another look after a few days.
It probably bugged me too!</p>
<p>Be patient with me.</p>
<p>If I had to guess, I'd say that YAMLScript v0 will be have a stable release
sometime before March 2024.
I'll continue blogging the progress as I go, so it shouldn't be hard for you to
decide when to start using YAMLScript for real.</p>
<p>Overall the whole thing is going extremely well, and I'm having a lot of fun.
It's important to be transparent with you about where things are at.</p>
<p>Stick with me... This is going to be awesome!</p>
<p>— Ingy döt Net</p>
</details>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Unwrapping Gifts</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-05/"/>
      <updated>2023-12-05T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-05/</id>
      <content type="html">
        <![CDATA[
      <p>It's certainly a relief now that I've told you the big secret about YAMLScript.
Now that you know that YAMLScript is really Clojure, I don't have to dance
around the subject anymore.
I didn't want to scare you away by going Full-Lisp on you from the start!</p>
<p>Now we can just get into it.
We can write, run and load YAMLScript until the cows come home.</p>
<p>But wait... How do we do that?
You don't even have YS installed yet!</p>
<h3>Welcome to Day 5 of the YAMLScript Advent Calendar</h3>
<p>Today we're going to learn how to install YAMLScript a couple different ways.</p>
<p>Luckily for you I just finished creating the <a href="https://github.com/yaml/yamlscript/releases/tag/0.1.20">first official YAMLScript
release</a>.
What a coincidence!</p>
<p>At he moment there are only releases published for Linux x86_64 and macOS
aarch64.
If you happen to be running on one of those platforms, you can run the following
command to install YAMLScript's CLI, <code>ys</code>:</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">curl</span> https://yamlscript.org/install-ys <span class="token operator">|</span> <span class="token function">bash</span></code></pre>
<p>This installer defaults to installing <code>ys</code> into <code>/usr/local/bin</code> so you probably
need to run it as root or with <code>sudo</code>:</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">curl</span> https://yamlscript.org/install-ys <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">bash</span></code></pre>
<p>If you want to install it somewhere else, like say <code>~/local/bin</code>, you can do:</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">curl</span> https://yamlscript.org/install-ys <span class="token operator">|</span> <span class="token assign-left variable">PREFIX</span><span class="token operator">=~</span>/local <span class="token function">bash</span></code></pre>
<p>Whereever you install it, make sure that the <code>$PREFIX/bin</code> directory is in your
<code>PATH</code> environment variable.</p>
<p>YAMLScript also provides a release for <code>libyamlscript.so</code>, the YAMLScript shared
library.
You can install it like above but with (some variation of):</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">curl</span> https://yamlscript.org/install-libyamlscript <span class="token operator">|</span> <span class="token function">bash</span></code></pre>
<p>We'll be using the shared library soon when we start playing around with using
YAMLScript from other programming languages.</p>
<h3>Building from Source</h3>
<p>The most reliable way to install YAMLScript is to build it from source.
We've put a lot of effort into making this as easy as possible.
You don't need any special prerequisites; just git, bash, curl and make.</p>
<p>The first thing you need to do is clone the YAMLScript repo:</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/yaml/yamlscript</code></pre>
<p>Then you can build and install the CLI with:</p>
<pre class="language-bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> yamlscript<br>$ <span class="token function">make</span> build<br>$ <span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span><br>or<br>$ <span class="token function">make</span> <span class="token function">install</span> <span class="token assign-left variable">PREFIX</span><span class="token operator">=</span><span class="token punctuation">..</span>.</code></pre>
<p>The <code>make install</code> command will install both <code>ys</code> and <code>libyamlscript.so</code> into
<code>$PREFIX/bin</code> and <code>$PREFIX/lib</code> respectively.</p>
<blockquote>
<p>Note: Currently you should take care not to run <code>make build</code> as root.
Since <code>make install</code> triggers <code>make build</code>, running <code>sudo make install</code>
without first running <code>make build</code> may fail.
This should be fixed soon.</p>
</blockquote>
<p>YAMLScript has a pretty sophisticated build system, built around GNU Make.
Even though the build uses Java, Clojure and GraalVM, you don't need to install
any of those things.
In fact, even if you have them installed, the build will ignore them.</p>
<h3>Running YAMLScript</h3>
<p>Now that you have YAMLScript installed, you can run it.
Try:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">--help</span></code></pre>
<p>It should display:</p>
<pre class="language-text"><code class="language-text">ys - The YAMLScript (YS) Command Line Tool<br><br>Usage: ys [options] [file]<br><br>Options:<br>  -r, --run                Compile and evaluate a YAMLScript file (default)<br>  -l, --load               Output the evaluated YAMLScript value<br>  -c, --compile            Compile YAMLScript to Clojure<br>  -e, --eval YSEXPR        Evaluate a YAMLScript expression<br>  -C, --clj                Treat input as Clojure code<br><br>  -m, --mode MODE          Add a mode tag: code, data, or bare (only for --eval/-e)<br>  -p, --print              Print the result of --run in code mode<br><br>  -o, --output             Output file for --load or --compile<br>  -t, --to FORMAT          Output format for --load<br><br>  -J, --json               Output JSON for --load<br>  -Y, --yaml               Output YAML for --load<br>  -E, --edn                Output EDN for --load<br><br>  -X, --debug              Debug mode: print full stack trace for errors<br>  -x, --debug-stage STAGE  Display the result of stage(s)<br>      --version            Print version and exit<br>  -h, --help               Print this help and exit</code></pre>
<p>In the next day or two we'll go over all of these options in detail.</p>
<p>Here's a quick example of how to run YAMLScript to process a file from the
internet that Google just told me about:</p>
<pre class="language-bash"><code class="language-bash">$ <span class="token function">curl</span> <span class="token parameter variable">-s</span> https://gist.githubusercontent.com/chriscowley/8598119/raw/8f671464f914320281e5e75bb8dcbe11285d21e6/nfs.example.lan.yml <span class="token operator">|</span><br>  ys <span class="token parameter variable">-J</span> <span class="token operator">|</span> jq .classes<br><span class="token punctuation">{</span><br>  <span class="token string">"nfs::server"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span><br>    <span class="token string">"exports"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><br>      <span class="token string">"/srv/share1"</span>,<br>      <span class="token string">"/srv/share3"</span><br>    <span class="token punctuation">]</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>When <code>ys</code> notices there is data on STDIN, it will read the YS program from
there.
The <code>-J</code> option tells <code>ys</code> to <code>--load</code> the YS and output the evaluation to JSON.</p>
<p>Well that's a wrap.
Thanks again for following along each day.</p>
<p>I'll see you tomorrow for day 6 of YAMLScript Advent 2023!</p>
<p>&nbsp;</p>
<details><summary style="color:#888">Santa's little secrets...</summary>
<p>In December 2023 YAMLScript is a work in progress.</p>
<p>This is not to say that it's vaporware, or a toy proof of concept.
It has a working compiler, runtime and CLI.
It has unit tests that must pass for every commit pushed to the main branch.
It's well thought out and has a clear direction that I continually vet with a
small group of talented and trusted people.</p>
<p>But that in turn not to say that you should use it in production today.
I encourage you to start playing with it, and I'm committed to backwards
compatibility for stable releases.
But we're not quite there yet.
Caveat usor!</p>
<p>YAMLScript is evolving fast.
While I'm writing these posts, I'm also writing the code for new features and
fixing bugs as I go.
I've had the Advent plan for over a month now, and I had planned to be further
along before December 1st, but such are the time estimates of hackers.</p>
<p>I am attempting to make sure that the code examples in these posts are always
using the implemented features, but sometimes I may fall a few hours behind.
Often I need to write the examples using code patterns that actually work but
are not the ones I preferred to best make a point.</p>
<p>As I fix bugs, implement features and tweak the language, I will update the
posts accordingly.
If you see something that bugs you, try taking another look after a few days.
It probably bugged me too!</p>
<p>Be patient with me.</p>
<p>If I had to guess, I'd say that YAMLScript v0 will be have a stable release
sometime before March 2024.
I'll continue blogging the progress as I go, so it shouldn't be hard for you to
decide when to start using YAMLScript for real.</p>
<p>Overall the whole thing is going extremely well, and I'm having a lot of fun.
It's important to be transparent with you about where things are at.</p>
<p>Stick with me... This is going to be awesome!</p>
<p>— Ingy döt Net</p>
</details>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Modes of Transportation</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-06/"/>
      <updated>2023-12-06T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-06/</id>
      <content type="html">
        <![CDATA[
      <p>How do you get around?
Some people walk, some ride bikes, some drive cars (or the cars drive them),
some take trains, some in planes, so many ways, even some in sleighs.</p>
<p>In YAMLScript, data gets around via various modes of transportation...
3 modes to be exact.</p>
<p>Rememeber back on December 3rd when we talked about the 2 different states that
a YAMLScript program can be in?
In one state <code>say</code> is a function, and in the other it's just a plain string.</p>
<p>We call these states &quot;modes&quot;, and there is actually three of them.</p>
<h3>Welcome to Day 6 of the YAMLScript Advent Calendar</h3>
<p>YAMLScript has these 3 modes:</p>
<ul>
<li>
<p>Code Mode</p>
<p>A starting <code>!yamlscript/v0</code> tag puts the YS file into Code Mode.
Unquoted strings are code expressions which are further parsed into AST
forms.
A <code>!</code> tag can switch the mode to Data Mode.</p>
</li>
<li>
<p>Data Mode</p>
<p>A starting <code>!yamlscript/v0/data</code> tag puts the YS file into Data Mode.
Everything is the regular YAML data language that you are used to.
But a <code>!</code> tag can switch the mode to Code Mode.</p>
</li>
<li>
<p>Bare Mode</p>
<p>Without a magic starting <code>!yamlscript</code> tag, the YS file is in Bare Mode.
This is like Data Mode but you aren't allowed to ever switch to Code Mode.
This is the default mode for YAMLScript files, and the reason we can claim
that almost all existing YAML files are valid YAMLScript files.
<em>Specifically all those that adhere to the JSON data model, which is almost
all YAML config files.</em></p>
</li>
</ul>
<p>The <code>ys</code> CLI tool will implicitly add a <code>!yamlscript/v0</code> tag when you use the
<code>--eval</code> (aka <code>-e</code>) option, unless you actually provide a tag yourself.
This is simply for convenience when you are testing out code snippets.</p>
<p>Note that you can use multiple <code>-e</code> options and each one acts like a separate
line of code in a file.</p>
<p>So <code>ys -e 'say: &quot;Hello&quot;' -e 'say: &quot;World&quot;'</code> is the same as this YS program:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"Hello"</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"World"</span></code></pre>
<p>If you wanted to write a <code>ys</code> one-liner that used Data Mode, you could do this:
<code>ys --load -e '!yamlscript/v0/data' -e 'foo: 111' -e 'bar: 222'</code> which is the
same as this YS program:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0/data</span><br><span class="token key atrule">foo</span><span class="token punctuation">:</span> <span class="token number">111</span><br><span class="token key atrule">bar</span><span class="token punctuation">:</span> <span class="token number">222</span></code></pre>
<p>If you wanted to write a <code>ys</code> one-liner that used Bare Mode, you could do this:
<code>ys --load -e </code>!yamlscript/v0/bare<code> -e 'foo: 111' -e 'bar: 222'</code> which is the
same as the Data Mode example above.</p>
<p>There's actually a better way to write Data and Bare Mode one-liners.
The <code>ys</code> command has a <code>--mode</code> (aka <code>-m</code>) option that lets you set the mode to
<code>code</code> (<code>c</code>), <code>data</code> (<code>d</code>) or <code>bare</code> (<code>b</code>).</p>
<p>Thus the last one liner could be written as:
<code>ys -mb -l -e 'foo: 111' -e 'bar: 222'</code>.</p>
<blockquote>
<p>Note: The <code>-m</code> option only works with the <code>-e</code> option.
You can't use it to change the mode of a file that you are loading or running.</p>
</blockquote>
<h3>Switching Modes</h3>
<p>In YAML tags are words that start with <code>!</code>.
They are instructions to the YAML loader (specifically to the constructor phase)
about what exactly to construct.</p>
<p>It's quite rare to see a YAML tag in the wild.
But here's something you probably didn't know...
Every untagged node in an internal YAML loader tree is implicitly assigned a
tag.
This process (of a YAML loader) is called &quot;tag resolution&quot;.
This is how the unquoted string <code>123</code> becomes the integer <code>123</code>.
It is implicitly tagged with <code>!!int</code>, which happens to be shorthand for
<code>tag:yaml.org,2002:int</code>.</p>
<p>All YAML loaders understand the set of <code>yaml.org,2002</code> tags: <code>!!map</code>, <code>!!seq</code>,
<code>!!str</code>, etc.
In fact you are free to use these tags in YAMLScript programs, even in Bare
Mode.
But there is really no good reason to do so.</p>
<p>The <code>!</code> tag is a valid YAML tag, but it is special in YAMLScript.
It switches between Code Mode and Data Mode.</p>
<p>If you think <code>!</code> looks weird, there is another cleaner looking way to switch
from Code Mode to Data Mode.</p>
<p>You can use <code>::</code> instead of <code>:</code> to separate the key and value of a mapping.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br>my<span class="token punctuation">-</span>map =<span class="token punctuation">:</span><span class="token punctuation">:</span><br>  foo = 111<br>  bar = 222</code></pre>
<p>is the same as:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">my-map =</span><span class="token punctuation">:</span> <span class="token tag">!</span><br>  <span class="token key atrule">foo</span><span class="token punctuation">:</span> <span class="token number">111</span><br>  <span class="token key atrule">bar</span><span class="token punctuation">:</span> <span class="token number">222</span></code></pre>
<p>At this point you can't do the same thing to switch from Data Mode to Code Mode.</p>
<p>Well that concludes our coverage of YAMLScript a la Mode!
Mmmm... Now doesn't that just sound delicious? (or at least fashionable!)</p>
<p>I'll see you tomorrow for day 7 of YAMLScript Advent 2023!</p>
<p>&nbsp;</p>
<details><summary style="color:#888">Santa's little secrets...</summary>
<p>In December 2023 YAMLScript is a work in progress.</p>
<p>This is not to say that it's vaporware, or a toy proof of concept.
It has a working compiler, runtime and CLI.
It has unit tests that must pass for every commit pushed to the main branch.
It's well thought out and has a clear direction that I continually vet with a
small group of talented and trusted people.</p>
<p>But that in turn not to say that you should use it in production today.
I encourage you to start playing with it, and I'm committed to backwards
compatibility for stable releases.
But we're not quite there yet.
Caveat usor!</p>
<p>YAMLScript is evolving fast.
While I'm writing these posts, I'm also writing the code for new features and
fixing bugs as I go.
I've had the Advent plan for over a month now, and I had planned to be further
along before December 1st, but such are the time estimates of hackers.</p>
<p>I am attempting to make sure that the code examples in these posts are always
using the implemented features, but sometimes I may fall a few hours behind.
Often I need to write the examples using code patterns that actually work but
are not the ones I preferred to best make a point.</p>
<p>As I fix bugs, implement features and tweak the language, I will update the
posts accordingly.
If you see something that bugs you, try taking another look after a few days.
It probably bugged me too!</p>
<p>Be patient with me.</p>
<p>If I had to guess, I'd say that YAMLScript v0 will be have a stable release
sometime before March 2024.
I'll continue blogging the progress as I go, so it shouldn't be hard for you to
decide when to start using YAMLScript for real.</p>
<p>Overall the whole thing is going extremely well, and I'm having a lot of fun.
It's important to be transparent with you about where things are at.</p>
<p>Stick with me... This is going to be awesome!</p>
<p>— Ingy döt Net</p>
</details>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Sharpen Your Tools</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-07/"/>
      <updated>2023-12-07T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-07/</id>
      <content type="html">
        <![CDATA[
      <p>Wanna make some fun toys with YAMLScript?
You'll need some sharp tools.
You think those elves make all those toys with dull tools?</p>
<p>The CLI tool <code>ys</code> is the main tool you'll use to work with YAMLScript.
Today we'll learn about all the things you can do with it.</p>
<h3>Welcome to Day 7 of the YAMLScript Advent Calendar</h3>
<p>On Tuesday you learned how to install YAMLScript.
Reminder, here's the quick way to install the latest version:</p>
<pre class="language-bash"><code class="language-bash">$ <span class="token function">curl</span> https://yamlscript.org/install-ys <span class="token operator">|</span> <span class="token assign-left variable">PREFIX</span><span class="token operator">=~</span>/.yamlscript <span class="token function">bash</span><br>$ <span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$HOME</span>/.yamlscript/bin:<span class="token environment constant">$PATH</span><br>$ ys <span class="token parameter variable">--version</span><br>YAMLScript v0.1.21</code></pre>
<p>The best first command to run is <code>ys --help</code>:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">--help</span><br>ys - The YAMLScript <span class="token punctuation">(</span>YS<span class="token punctuation">)</span> Command Line Tool<br><br>Usage: ys <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token punctuation">[</span>file<span class="token punctuation">]</span><br><br>Options:<br>  -r, <span class="token parameter variable">--run</span>                Compile and evaluate a YAMLScript <span class="token function">file</span> <span class="token punctuation">(</span>default<span class="token punctuation">)</span><br>  -l, <span class="token parameter variable">--load</span>               Output the evaluated YAMLScript value<br>  -c, <span class="token parameter variable">--compile</span>            Compile YAMLScript to Clojure<br>  -e, <span class="token parameter variable">--eval</span> YSEXPR        Evaluate a YAMLScript expression<br>  -C, <span class="token parameter variable">--clj</span>                Treat input as Clojure code<br><br>  -m, <span class="token parameter variable">--mode</span> MODE          Add a mode tag: code, data, or bare <span class="token punctuation">(</span>only <span class="token keyword">for</span> --eval/-e<span class="token punctuation">)</span><br>  -p, <span class="token parameter variable">--print</span>              Print the result of <span class="token parameter variable">--run</span> <span class="token keyword">in</span> code mode<br><br>  -o, <span class="token parameter variable">--output</span>             Output <span class="token function">file</span> <span class="token keyword">for</span> <span class="token parameter variable">--load</span> or <span class="token parameter variable">--compile</span><br>  -t, <span class="token parameter variable">--to</span> FORMAT          Output <span class="token function">format</span> <span class="token keyword">for</span> <span class="token parameter variable">--load</span><br><br>  -J, <span class="token parameter variable">--json</span>               Output JSON <span class="token keyword">for</span> <span class="token parameter variable">--load</span><br>  -Y, <span class="token parameter variable">--yaml</span>               Output YAML <span class="token keyword">for</span> <span class="token parameter variable">--load</span><br>  -E, <span class="token parameter variable">--edn</span>                Output EDN <span class="token keyword">for</span> <span class="token parameter variable">--load</span><br><br>  -X, <span class="token parameter variable">--debug</span>              Debug mode: print full stack trace <span class="token keyword">for</span> errors<br>  -x, --debug-stage STAGE  Display the result of stage<span class="token punctuation">(</span>s<span class="token punctuation">)</span><br>      <span class="token parameter variable">--version</span>            Print version and <span class="token builtin class-name">exit</span><br>  -h, <span class="token parameter variable">--help</span>               Print this <span class="token builtin class-name">help</span> and <span class="token builtin class-name">exit</span></code></pre>
<h3>Ready, set, actions!</h3>
<p>The first thing to notice is that <code>ys</code> has 3 &quot;actions&quot;:</p>
<ul>
<li><code>--run</code> (default) - Compile and evaluate a YAMLScript file</li>
<li><code>--load</code> - Output the evaluated YAMLScript value as JSON (by default)</li>
<li><code>--compile</code> - Compile YAMLScript code to Clojure code</li>
</ul>
<p>For each action you'll need some YAMLScript source code.
This can come from 3 different places:</p>
<ul>
<li>The <code>--eval</code> (<code>-e</code>) option - specifies a line of YAMLScript code.
You can use this option multiple times to specify multiple lines of code.</li>
<li>A file path - specify a path to a file containing YAMLScript code.</li>
<li>Standard input - specify <code>-</code> as the file path to read YAMLScript code from
standard input.
If no file or <code>-e</code> options are specified, <code>ys</code> will check to see if there is
data on stdin.
That means you can leave off the <code>-</code> and pipe data into <code>ys</code> like this:
<code>echo $'!yamlscript/v0\nsay: &quot;Hello&quot;' | ys</code>.
Of course, it doesn't hurt to specify the <code>-</code> anyway.</li>
</ul>
<h3>Running Clojure  with <code>ys</code></h3>
<p>Clojure code is often valid YAMLScript code:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">--compile</span> <span class="token parameter variable">-e</span> <span class="token string">'(println (+ 1 2))'</span><br><span class="token punctuation">(</span>println <span class="token punctuation">(</span>+ <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">))</span></code></pre>
<p>This YAMLScript compiles to the exact same Clojure code.</p>
<p>If you want the code you run to be considered to be Clojure code (thus not
compiled by the yamlscript compiler), you can use the <code>--clj</code> (<code>-C</code>) option.
This is useful when you want to test out the YAMLScript runtime envronment
directly with Clojure code.</p>
<p>Also you can pipe the output of <code>ys --compile</code> to <code>ys --clj</code> to run the
compiler's Clojure code ouput:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-c</span> <span class="token parameter variable">-e</span> <span class="token string">'say: 123'</span> <span class="token operator">|</span> ys <span class="token parameter variable">-C</span></code></pre>
<h3>Modes and Formats</h3>
<p>We learned about modes and the <code>--mode</code> option yesterday.
You can set the mode for <code>--eval</code> (<code>-e</code>) code with the <code>--mode</code> (<code>-m</code>) option.
The accepted values are <code>code</code> (<code>c</code>), <code>data</code> (<code>d</code>) and <code>bare</code> (<code>b</code>).</p>
<p>When you &quot;load&quot; YAMLScript using <code>--load</code> you get the result printed to stdout
as JSON.
These are 3 formatting options to control how the output is displayed:</p>
<ul>
<li><code>--json</code> (<code>-J</code>) - Output JSON (default)
Note that this JSON is a bit more nicely formatted than the default output.</li>
<li><code>--yaml</code> (<code>-Y</code>) - Output YAML</li>
<li><code>--edn</code> (<code>-E</code>) - Output EDN. EDN is Clojure's native data format.
It is also valid Clojure code.</li>
</ul>
<p>Note that when you specify a formatting option, it implies the <code>--load</code> action.</p>
<h3>Debugging</h3>
<p>When you &quot;run&quot; a YAMLScript program it doesn't print anything unless you use a
printing command.
This isn't surprising; all languages work this way.</p>
<p>Sometimes you want to know what the final value of the run was.
To get this you could print it with <code>say.</code>
You can also use the special <code>--print</code> (<code>-p</code>) option, which does exactly that
(with less typing)..</p>
<p>Finally there a 2 special debugging options:</p>
<ul>
<li><code>--debug</code> (<code>-X</code>) - Print a full stack trace for errors (more info)</li>
<li><code>--debug-stage</code> (<code>-x</code>) - Display the result of a stage/stages</li>
</ul>
<p>The <code>--debug-stage</code> option is super useful for understanding exactly how
YAMLScript code compiles to Clojure code.</p>
<p>For example, to see the internal AST when compiling some YAMLScript:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-c</span> <span class="token parameter variable">-e</span> <span class="token string">'say: "Hello"'</span> <span class="token parameter variable">-xconstruct</span><br>*** construct output ***<br><span class="token punctuation">{</span>:Lst <span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym say<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"Hello"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br><br><span class="token punctuation">(</span>say <span class="token string">"Hello"</span><span class="token punctuation">)</span></code></pre>
<p>And to see all 7 compilation stages:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-c</span> <span class="token parameter variable">-e</span> <span class="token string">'say: "Hello"'</span> <span class="token parameter variable">-xall</span><br>*** parse output ***<br><span class="token punctuation">(</span><span class="token punctuation">{</span>:+ <span class="token string">"+MAP"</span>, :<span class="token operator">!</span> <span class="token string">"yamlscript/v0"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span>:+ <span class="token string">"=VAL"</span>, :<span class="token operator">=</span> <span class="token string">"say"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span>:+ <span class="token string">"=VAL"</span>, :$ <span class="token string">"Hello"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span>:+ <span class="token string">"-MAP"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><br><br>*** compose output ***<br><span class="token punctuation">{</span>:<span class="token operator">!</span> <span class="token string">"yamlscript/v0"</span>, :% <span class="token punctuation">[</span><span class="token punctuation">{</span>:<span class="token operator">=</span> <span class="token string">"say"</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:$ <span class="token string">"Hello"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br><br>*** resolve output ***<br><span class="token punctuation">{</span>:ysm <span class="token punctuation">(</span><span class="token punctuation">{</span>:ysx <span class="token string">"say"</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:ysi <span class="token string">"Hello"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><br><br>*** build output ***<br><span class="token punctuation">{</span>:ysm <span class="token punctuation">(</span><span class="token punctuation">{</span>:Sym say<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"Hello"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><br><br>*** transform output ***<br><span class="token punctuation">{</span>:ysm <span class="token punctuation">(</span><span class="token punctuation">{</span>:Sym say<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"Hello"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><br><br>*** construct output ***<br><span class="token punctuation">{</span>:Lst <span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym say<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"Hello"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br><br>*** print output ***<br><span class="token string">"(say <span class="token entity" title="\&quot;">\"</span>Hello<span class="token entity" title="\&quot;">\"</span>)<span class="token entity" title="\n">\n</span>"</span><br><br><span class="token punctuation">(</span>say <span class="token string">"Hello"</span><span class="token punctuation">)</span></code></pre>
<p>We'll go over all of these stages in detail in a future post.</p>
<p>In the meantime, try out your new <code>ys</code> tool and see what you can do with it.
The more you use it, the sharper it will get.</p>
<p>I'll see you tomorrow for day 8 of YAMLScript Advent 2023!</p>
<p>&nbsp;</p>
<details><summary style="color:#888">Santa's little secrets...</summary>
<p>In December 2023 YAMLScript is a work in progress.</p>
<p>This is not to say that it's vaporware, or a toy proof of concept.
It has a working compiler, runtime and CLI.
It has unit tests that must pass for every commit pushed to the main branch.
It's well thought out and has a clear direction that I continually vet with a
small group of talented and trusted people.</p>
<p>But that in turn not to say that you should use it in production today.
I encourage you to start playing with it, and I'm committed to backwards
compatibility for stable releases.
But we're not quite there yet.
Caveat usor!</p>
<p>YAMLScript is evolving fast.
While I'm writing these posts, I'm also writing the code for new features and
fixing bugs as I go.
I've had the Advent plan for over a month now, and I had planned to be further
along before December 1st, but such are the time estimates of hackers.</p>
<p>I am attempting to make sure that the code examples in these posts are always
using the implemented features, but sometimes I may fall a few hours behind.
Often I need to write the examples using code patterns that actually work but
are not the ones I preferred to best make a point.</p>
<p>As I fix bugs, implement features and tweak the language, I will update the
posts accordingly.
If you see something that bugs you, try taking another look after a few days.
It probably bugged me too!</p>
<p>Be patient with me.</p>
<p>If I had to guess, I'd say that YAMLScript v0 will be have a stable release
sometime before March 2024.
I'll continue blogging the progress as I go, so it shouldn't be hard for you to
decide when to start using YAMLScript for real.</p>
<p>Overall the whole thing is going extremely well, and I'm having a lot of fun.
It's important to be transparent with you about where things are at.</p>
<p>Stick with me... This is going to be awesome!</p>
<p>— Ingy döt Net</p>
</details>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Going to the Library</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-08/"/>
      <updated>2023-12-08T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-08/</id>
      <content type="html">
        <![CDATA[
      <p>Programming in YAMLScript is as easy as reading a book.
The only thing you really need is some good books!
For that let's go to the library.</p>
<p>By books of course I mean YAMLScript functions.
And by library I mean the YAMLScript Standard Library!
There you'll find all-time best sellers like <code>map</code>, <code>filter</code>, <code>reduce</code> and
<code>say</code>.</p>
<p>And Standard isn't the only Library in town...</p>
<h3>Welcome to Day 8 of the YAMLScript Advent Calendar</h3>
<p>In our YS programming so far, we've been using various functions like <code>say</code>,
<code>take</code>, <code>keys</code>, <code>join</code> and <code>map</code>.
Also we've been using various operators like <code>+</code>, <code>*</code>, <code>=&gt;</code> and <code>..</code>.
Operators are just functions with names made out of punctuation characters.</p>
<p>Where do these functions come from?
Are they built into the YAMLScript language?</p>
<p>Nope. They all come from the Library!</p>
<details><summary>
<strong style="color:brown">Libraries and Namespaces</strong></summary>
<p>It's probably a good idea to explain what a Clojure library is.
And we should probably talk about namespaces too.
Don't worry, it's quite simple.</p>
<p>A library is a file that contains a namespace and a bunch of functions (who
belong to that library/namespace).
The namespace name is made up of 2 or more words separated by the <code>.</code> character.
The name corresponds to the file path of the library.</p>
<p>For example (in Clojure) the <code>foo.bar</code> library would contain a <code>foo.bar</code>
namespace and be located at <code>foo/bar.clj</code> in your Java classpath.
To access a function called <code>thinger</code> in <code>foo.bar</code>, you would use the fully
qualified name (aka a Clojure symbol) <code>foo.bar/thinger</code>.</p>
<p>YAMLScript is the same except:</p>
<ul>
<li>File names end with <code>.ys</code></li>
<li>The 2 or more words are separated by <code>::</code> instead of <code>.</code></li>
<li>A fully qualified symbol looks like <code>foo::bar.thinger</code>.
<ul>
<li>You'll find out later why this is really cool</li>
</ul>
</li>
</ul>
</details>
<p>The YAMLScript runtime has several libraries that are always available.
The two primary ones are <code>clojure::core</code> and <code>ys::std</code>.</p>
<p>The <code>clojure::core</code> library is what YAMLScript calls Clojure's famous
<code>clojure.core</code> library.
In Clojure (and thus YAMLScript!) <code>clojure.core</code> is the heart and soul of the
language.
It's where all the Good Parts live.
All of the functions (and macros) that you use constantly in your day-to-day
programming.</p>
<p>How many publicly accessible functions does <code>clojure::core</code> give you?
581!!</p>
<p>How do I know that?
YAMLScript just told me so:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-pe</span> <span class="token string">'->(clojure::core quote find-ns ns-publics count)'</span><br><span class="token number">581</span></code></pre>
<p>That's a lot of functions!</p>
<details><summary><strong style="color:red">Why not 671?</strong></summary>
<p>Honestly it's not as many as the real <code>clojure.core</code> library called from
Clojure.</p>
<pre class="language-bash"><code class="language-bash">$ clojure <span class="token parameter variable">-M</span> <span class="token parameter variable">-e</span> <span class="token string">'(-> clojure.core quote ns-publics count)'</span><br><span class="token number">671</span></code></pre>
<p>The reason for this is because YAMLScript uses a special version of Clojure
the <a href="https://github.com/babashka/sci">SCI</a> (Small Clojure Interpreter).</p>
<p>SCI offers a subset of Clojure's functionality, but it's a very useful subset.
It's also a &quot;safe&quot; subset.</p>
<p>I don't think you'll run into anything that's not available in your day to day
YAMLScripting.
If you do, give me a ring and we'll see what we can do to get it added.</p>
</details>
<p>The <code>clojure.core</code> library is very well documented so we won't talk about it
more right now.</p>
<p>Let's discuss the other one I mentioned, <code>ys::std</code>.
This is the YAMLScript Standard Library.
It's where you'll find functions that make YS nicer to work with.
The <code>say</code> function that shows up constantly is defined as <code>ys::std.say</code>.</p>
<p>How many functions does it offer?</p>
<pre class="language-bash"><code class="language-bash">$ YS <span class="token parameter variable">-pe</span> <span class="token string">'->(ys::std quote find-ns ns-publics count)'</span><br><span class="token number">17</span></code></pre>
<p>Not that many yet, but it is still being actively defined.</p>
<p>Here's a few of them:</p>
<ul>
<li><code>say</code> - A shorter way to say <code>println</code></li>
<li><code>warn</code> - Like <code>say</code> but prints to stderr</li>
<li><code>load</code> - Load an external YAMLScript file</li>
<li><code>=&gt;</code> - <code>=&gt;: 123</code> or <code>(=&gt; 123)</code> compiles to <code>123</code></li>
<li><code>pretty</code> - Pretty formats a data structure (without printing it)</li>
<li><code>toI</code>, <code>toS</code>, <code>toB</code> etc casting functions (Integer, String, Boolean)</li>
<li><code>_+</code> and <code>_*</code> - The polymorphic versions of <code>+</code> and <code>*</code> infix operators</li>
</ul>
<p>The <code>ys::std</code> library will certainly grow over time.
Functions is this library use names that are not used by <code>clojure.core</code>
functions.</p>
<h3>Other <code>ys::</code> Libraries</h3>
<p>There are currently 3 other <code>ys::</code> libraries that are always available.</p>
<ul>
<li><code>ys::yaml</code> - YAML <code>load</code> and <code>dump</code> functions</li>
<li><code>ys::json</code> - JSON <code>load</code> and <code>dump</code> functions</li>
<li><code>ys::ys</code> - <code>compile</code>, <code>eval</code> and <code>load</code> YS from within YS!</li>
</ul>
<p>For fun let's write a silly YS program that uses them.</p>
<p>Let's call it <code>silly.ys</code>:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment">#!/usr/bin/env ys-0</span><br><br><span class="token key atrule">my-yaml =</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string"><br>  - Hello<br>  - Salutations<br>  - Ho Ho Ho<br>  - Merry Christmas<br>  - Happy Holidays<br>  - Seasons Greetings<br>  - Happy New Year<br>  - Happy Hanukkah<br>  - Happy Kwanzaa</span><br><br><span class="token key atrule">my-json =</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string"><br>  [ "World",<br>    "Santa",<br>    "Elves",<br>    "Reindeer",<br>    "Snowman",<br>    "Mrs. Claus",<br>    "Rudolph",<br>    "Frosty",<br>    "Kids" ]</span><br><br><span class="token key atrule">greets =</span><span class="token punctuation">:</span> ys<span class="token punctuation">:</span><span class="token punctuation">:</span>yaml.load(my<span class="token punctuation">-</span>yaml)<br><br><span class="token key atrule">names =</span><span class="token punctuation">:</span> ys<span class="token punctuation">:</span><span class="token punctuation">:</span>json.load(my<span class="token punctuation">-</span>json)<br><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"$rand-nth(greets), $rand-nth(names)!!"</span></code></pre>
<p>Now let's run it a few times:</p>
<pre class="language-bash"><code class="language-bash">$ <span class="token keyword">for</span> <span class="token for-or-select variable">x</span> <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">do</span> ys silly.ys<span class="token punctuation">;</span> <span class="token keyword">done</span><br>Happy Holidays, Kids<span class="token operator">!</span><span class="token operator">!</span><br>Hello, World<span class="token operator">!</span><span class="token operator">!</span><br>Happy New Year, World<span class="token operator">!</span><span class="token operator">!</span><br>Hello, Rudolph<span class="token operator">!</span><span class="token operator">!</span><br>Salutations, Santa<span class="token operator">!</span><span class="token operator">!</span><br>Salutations, Mrs. Claus<span class="token operator">!</span><span class="token operator">!</span><br>Happy Hanukkah, Mrs. Claus<span class="token operator">!</span><span class="token operator">!</span><br>Merry Christmas, Santa<span class="token operator">!</span><span class="token operator">!</span><br>Ho Ho Ho, Rudolph<span class="token operator">!</span><span class="token operator">!</span><br>Hello, Elves<span class="token operator">!</span><span class="token operator">!</span></code></pre>
<p>That's a lot of fun!
We wrote a program in YAML to play with some YAML that was inside the YAML!</p>
<p>I hope you're starting to see the power of YAMLScript, and I hope you have a wonderful day.</p>
<p>Full disclosure: I'm stuck in the Winnipeg airport, writing this and hacking on
YAMLScript because my flight's toilets stopped working and they decided to land
here for the night. True story.</p>
<p>Tune in tomorrow for Day 9 of the YAMLScript Advent Calendar.</p>
<p>&nbsp;</p>
<details><summary style="color:#888">Santa's little secrets...</summary>
<p>In December 2023 YAMLScript is a work in progress.</p>
<p>This is not to say that it's vaporware, or a toy proof of concept.
It has a working compiler, runtime and CLI.
It has unit tests that must pass for every commit pushed to the main branch.
It's well thought out and has a clear direction that I continually vet with a
small group of talented and trusted people.</p>
<p>But that in turn not to say that you should use it in production today.
I encourage you to start playing with it, and I'm committed to backwards
compatibility for stable releases.
But we're not quite there yet.
Caveat usor!</p>
<p>YAMLScript is evolving fast.
While I'm writing these posts, I'm also writing the code for new features and
fixing bugs as I go.
I've had the Advent plan for over a month now, and I had planned to be further
along before December 1st, but such are the time estimates of hackers.</p>
<p>I am attempting to make sure that the code examples in these posts are always
using the implemented features, but sometimes I may fall a few hours behind.
Often I need to write the examples using code patterns that actually work but
are not the ones I preferred to best make a point.</p>
<p>As I fix bugs, implement features and tweak the language, I will update the
posts accordingly.
If you see something that bugs you, try taking another look after a few days.
It probably bugged me too!</p>
<p>Be patient with me.</p>
<p>If I had to guess, I'd say that YAMLScript v0 will be have a stable release
sometime before March 2024.
I'll continue blogging the progress as I go, so it shouldn't be hard for you to
decide when to start using YAMLScript for real.</p>
<p>Overall the whole thing is going extremely well, and I'm having a lot of fun.
It's important to be transparent with you about where things are at.</p>
<p>Stick with me... This is going to be awesome!</p>
<p>— Ingy döt Net</p>
</details>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Coding with Style</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-09/"/>
      <updated>2023-12-09T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-09/</id>
      <content type="html">
        <![CDATA[
      <p>What's the best thing about Rudolph's nose?
Is it that lights the way for Santa's sleigh?
I'm calling BS on that.
I'd say it's the main thing that gives the whole <strong>Sanata Story some Serious
Style!</strong></p>
<p>Good programmers do more than just get their solutions right.
They do the whole thing with style.
That makes the program easier to read, understand and maintain.
It also gives the code a certain je ne sais quoi.</p>
<h3>Welcome to Day 9 of the YAMLScript Advent Calendar</h3>
<p>We know that YAMLScript compiles to Clojure.
And we know that YAML doesn't really look anything like a Lisp.
But it turns out that YAMLScript can use as much or as little Lisp style as you
want it to.
It's all about your personal style.</p>
<p>Here's a YS program that sings my favorite drinking song:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment">#!/usr/bin/env ys-0</span><br><br><span class="token comment"># Print the verses to "99 Bottles of Beer"</span><br><span class="token comment">#</span><br><span class="token comment"># usage:</span><br><span class="token comment">#   ys 99-bottles.ys [&lt;count>]</span><br><br>defn main(&amp;<span class="token punctuation">[</span>number<span class="token punctuation">]</span>)<span class="token punctuation">:</span><br>  each <span class="token punctuation">[</span>n ((number <span class="token punctuation">|</span><span class="token punctuation">|</span> 99) .. 1)<span class="token punctuation">]</span><span class="token punctuation">:</span><br>    <span class="token key atrule">say</span><span class="token punctuation">:</span><br>      <span class="token key atrule">paragraph</span><span class="token punctuation">:</span> n<br><br><span class="token key atrule">defn paragraph(num)</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string"><br>  $(bottles num) of beer on the wall,<br>  $(bottles num) of beer.<br>  Take one down, pass it around.<br>  $(bottles (num - 1)) of beer on the wall.</span><br><br><span class="token key atrule">defn bottles(n)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">cond</span><span class="token punctuation">:</span><br>    (n == 0) "No more bottles"<br>    (n == 1) "1 bottle"<br>    <span class="token punctuation">:</span>else    str(n " bottles")</code></pre>
<p>Let's give it a try:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token number">99</span>-bottles.ys <span class="token number">3</span><br><span class="token number">3</span> bottles of beer on the wall,<br><span class="token number">3</span> bottles of beer.<br>Take one down, pass it around.<br><span class="token number">2</span> bottles of beer on the wall.<br><br><span class="token number">2</span> bottles of beer on the wall,<br><span class="token number">2</span> bottles of beer.<br>Take one down, pass it around.<br><span class="token number">1</span> bottle of beer on the wall.<br><br><span class="token number">1</span> bottle of beer on the wall,<br><span class="token number">1</span> bottle of beer.<br>Take one down, pass it around.<br>No <span class="token function">more</span> bottles of beer on the wall.</code></pre>
<p>I feel tipsy.</p>
<p>Let's compile this program to Clojure and see what it looks like:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-c</span> <span class="token number">99</span>-bottles.ys<br><span class="token punctuation">(</span>declare paragraph bottles<span class="token punctuation">)</span><br><span class="token punctuation">(</span>defn main <span class="token punctuation">[</span><span class="token operator">&amp;</span> <span class="token punctuation">[</span>number<span class="token punctuation">]</span><span class="token punctuation">]</span><br>  <span class="token punctuation">(</span>doall <span class="token punctuation">(</span>map say <span class="token punctuation">(</span>map paragraph <span class="token punctuation">(</span>rng <span class="token punctuation">(</span>or number <span class="token number">99</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">))</span><span class="token punctuation">))</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span>defn paragraph <span class="token punctuation">[</span>num<span class="token punctuation">]</span><br>  <span class="token punctuation">(</span>str<br>    <span class="token punctuation">(</span>bottles num<span class="token punctuation">)</span><br>    <span class="token string">" of beer on the wall,<span class="token entity" title="\n">\n</span>"</span><br>    <span class="token punctuation">(</span>bottles num<span class="token punctuation">)</span><br>    <span class="token string">" of beer.<span class="token entity" title="\n">\n</span>Take one down, pass it around.<span class="token entity" title="\n">\n</span>"</span><br>    <span class="token punctuation">(</span>bottles <span class="token punctuation">(</span>- num <span class="token number">1</span><span class="token punctuation">))</span><br>    <span class="token string">" of beer on the wall."</span> <span class="token string">"<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">))</span><br><span class="token punctuation">(</span>defn bottles <span class="token punctuation">[</span>n<span class="token punctuation">]</span><br>  <span class="token punctuation">(</span>cond<br>    <span class="token punctuation">(</span><span class="token operator">==</span> n <span class="token number">0</span><span class="token punctuation">)</span> <span class="token string">"No more bottles"</span><br>    <span class="token punctuation">(</span><span class="token operator">==</span> n <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1 bottle"</span> :else<br>    <span class="token punctuation">(</span>str n <span class="token string">" bottles"</span><span class="token punctuation">))</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span>apply main ARGV<span class="token punctuation">)</span></code></pre>
<p>It turns out that the compiled Clojure code is actually valid YAMLScript syntax
as well.
Well, almost.</p>
<p>The file is valid YAML.
It represents a single big string.
Normally YAML files represent a single big mapping or sequence, but they can
also define a top level scalar (string).</p>
<p>If I run this program though, it doesn't print anything.
The reason is simple.
We didn't give it the power to.
We didn't add the <code>!yamlscript/v0</code> tag to the beginning of the file.</p>
<p>If we do that it works fine.</p>
<p>So apparently we can write YAMLScript in a purely Lisp style.
The truth is you can write YAMLScript is a completely YAML style (no parens),
a completely Lisp style (all parens), or somewhere in between.</p>
<p>Good looking YS programs start with YAML style and then switch to the Lisp style
for certain nicer idioms.
Note that you can't switch back to YAML style once you've switched to Lisp
style.</p>
<p>Let's iterate on the above code and make it YAML just at the top level:</p>
<pre class="language-yaml"><code class="language-yaml">defn main <span class="token punctuation">[</span>&amp; <span class="token punctuation">[</span>number<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span><br>  (doall (map say (map paragraph (rng (or number 99) 1))))<br>defn paragraph <span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">:</span><br>  (str<br>    (bottles num)<br>    " of beer on the wall<span class="token punctuation">,</span>\n"<br>    (bottles num)<br>    " of beer.\nTake one down<span class="token punctuation">,</span> pass it around.\n"<br>    (bottles (<span class="token punctuation">-</span> num 1))<br>    " of beer on the wall." "\n")<br>defn bottles <span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">:</span><br>  (cond<br>    (== n 0) "No more bottles"<br>    (== n 1) "1 bottle" <span class="token punctuation">:</span>else<br>    (str n " bottles"))<br><span class="token key atrule">apply</span><span class="token punctuation">:</span> main ARGV</code></pre>
<p>That already looks a lot better.</p>
<p>We get a big win turning the <code>paragraph</code> into a YAML literal scalar (heredoc)
with string interpolation.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">defn paragraph(num)</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string"><br>  $(bottles num) of beer on the wall,<br>  $(bottles num) of beer.<br>  Take one down, pass it around.<br>  $(bottles (num - 1)) of beer on the wall.</span></code></pre>
<p>That's so much easier to read and understand.</p>
<p>I hope you are inspired to write some beautiful YAMLScript code.</p>
<p><strong>You've got style, baby!</strong></p>
<p>Come back tomorrow for day 10 of the YAMLScript Advent Calendar.</p>
<p>&nbsp;</p>
<details><summary style="color:#888">Santa's little secrets...</summary>
<p>In December 2023 YAMLScript is a work in progress.</p>
<p>This is not to say that it's vaporware, or a toy proof of concept.
It has a working compiler, runtime and CLI.
It has unit tests that must pass for every commit pushed to the main branch.
It's well thought out and has a clear direction that I continually vet with a
small group of talented and trusted people.</p>
<p>But that in turn not to say that you should use it in production today.
I encourage you to start playing with it, and I'm committed to backwards
compatibility for stable releases.
But we're not quite there yet.
Caveat usor!</p>
<p>YAMLScript is evolving fast.
While I'm writing these posts, I'm also writing the code for new features and
fixing bugs as I go.
I've had the Advent plan for over a month now, and I had planned to be further
along before December 1st, but such are the time estimates of hackers.</p>
<p>I am attempting to make sure that the code examples in these posts are always
using the implemented features, but sometimes I may fall a few hours behind.
Often I need to write the examples using code patterns that actually work but
are not the ones I preferred to best make a point.</p>
<p>As I fix bugs, implement features and tweak the language, I will update the
posts accordingly.
If you see something that bugs you, try taking another look after a few days.
It probably bugged me too!</p>
<p>Be patient with me.</p>
<p>If I had to guess, I'd say that YAMLScript v0 will be have a stable release
sometime before March 2024.
I'll continue blogging the progress as I go, so it shouldn't be hard for you to
decide when to start using YAMLScript for real.</p>
<p>Overall the whole thing is going extremely well, and I'm having a lot of fun.
It's important to be transparent with you about where things are at.</p>
<p>Stick with me... This is going to be awesome!</p>
<p>— Ingy döt Net</p>
</details>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>States and Ladders</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-10/"/>
      <updated>2023-12-10T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-10/</id>
      <content type="html">
        <![CDATA[
      <p>Santa is a busy guy.
He has a lot of work to do.
He has to make a list and check it twice.
He has to find out who's naughty and nice.
He has the monumental task of transforming wishes into happiness.</p>
<p>YS only needs to transform YAMLScript into Clojure.
But it's a bit more involved than you might think.</p>
<p>To make things easier the YS compiler breaks the transformation into eight
distinct States and seven distinct <s>Ladders</s> transformations.</p>
<h3>Welcome to Day 10 of the YAMLScript Advent Calendar</h3>
<p>Today we're going to learn more exactly how <code>ys --compile</code> turns YAMLScript into
Clojure.<br>
<em>Fair Warning: This is going to be a long post</em>.</p>
<p>The <code>ys</code> CLI has an awesome tool to visualize the transformation process any
time you are interested.
This might be for debugging where something went wrong, or just to learn more
about how the compiler works.</p>
<p>To begin this journey, let's use this visualizer in action.
You could write it like this:</p>
<pre class="language-bash"><code class="language-bash">ys <span class="token parameter variable">--compile</span> --debug-state<span class="token operator">=</span>all <span class="token parameter variable">-e</span> <span class="token string">'name =: "Clojure"'</span> <span class="token parameter variable">-e</span> <span class="token string">'say: "Hello, $name!"'</span></code></pre>
<p>The one line program is equivalent to the file containing:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">name =</span><span class="token punctuation">:</span> <span class="token string">"Clojure"</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"Hello, $name!"</span></code></pre>
<p>Let's run the command now (but we'll use the shorter options):</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-c</span> <span class="token parameter variable">-e</span> <span class="token string">'name =: "Clojure"'</span> <span class="token parameter variable">-e</span> <span class="token string">'say: "Hello, $name!"'</span> <span class="token parameter variable">-xall</span><br>*** parse output ***<br><span class="token punctuation">(</span><span class="token punctuation">{</span>:+ <span class="token string">"+MAP"</span>, :<span class="token operator">!</span> <span class="token string">"yamlscript/v0"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span>:+ <span class="token string">"=VAL"</span>, :<span class="token operator">=</span> <span class="token string">"name ="</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span>:+ <span class="token string">"=VAL"</span>, :$ <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span>:+ <span class="token string">"=VAL"</span>, :<span class="token operator">=</span> <span class="token string">"say"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span>:+ <span class="token string">"=VAL"</span>, :$ <span class="token string">"Hello, <span class="token variable">$name</span>!"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span>:+ <span class="token string">"-MAP"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><br><br>*** compose output ***<br><span class="token punctuation">{</span>:<span class="token operator">!</span> <span class="token string">"yamlscript/v0"</span>,<br> :% <span class="token punctuation">[</span><span class="token punctuation">{</span>:<span class="token operator">=</span> <span class="token string">"name ="</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:$ <span class="token string">"Clojure"</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:<span class="token operator">=</span> <span class="token string">"say"</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:$ <span class="token string">"Hello, <span class="token variable">$name</span>!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br><br>*** resolve output ***<br><span class="token punctuation">{</span>:ysm<br> <span class="token punctuation">[</span><span class="token punctuation">{</span>:ysx <span class="token string">"def name"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:ysi <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:ysx <span class="token string">"say"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:ysi <span class="token string">"Hello, <span class="token variable">$name</span>!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br><br>*** build output ***<br><span class="token punctuation">{</span>:ysm<br> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym def<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Sym name<span class="token punctuation">}</span><span class="token punctuation">]</span><br>  <span class="token punctuation">{</span>:Str <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:Sym say<span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:Lst <span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym str<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"Hello, "</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:Sym name<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><br><br>*** transform output ***<br><span class="token punctuation">{</span>:ysm<br> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym def<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Sym name<span class="token punctuation">}</span><span class="token punctuation">]</span><br>  <span class="token punctuation">{</span>:Str <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:Sym say<span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:Lst <span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym str<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"Hello, "</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:Sym name<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br><br>*** construct output ***<br><span class="token punctuation">{</span>:Lst<br> <span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym do<span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:Lst <span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym def<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Sym name<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"Clojure"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:Lst<br>   <span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym say<span class="token punctuation">}</span><br>    <span class="token punctuation">{</span>:Lst <span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym str<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"Hello, "</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:Sym name<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br><br>*** print output ***<br><span class="token string">"(def name <span class="token entity" title="\&quot;">\"</span>Clojure<span class="token entity" title="\&quot;">\"</span>)<span class="token entity" title="\n">\n</span>(say (str <span class="token entity" title="\&quot;">\"</span>Hello, <span class="token entity" title="\&quot;">\"</span> name <span class="token entity" title="\&quot;">\"</span>!<span class="token entity" title="\&quot;">\"</span>))<span class="token entity" title="\n">\n</span>"</span><br><br><span class="token punctuation">(</span>def name <span class="token string">"Clojure"</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span>say <span class="token punctuation">(</span>str <span class="token string">"Hello, "</span> name <span class="token string">"!"</span><span class="token punctuation">))</span></code></pre>
<p>Woah! That's a lot of output.
But it's exactly what I want to tell you about today.</p>
<p>At the bottom is the clojure code we expect.
Above that is the output of each of the seven transformations (aka the 7 states
that come after the first state: our YS input).</p>
<p>Let's look at each of these transformations in turn...</p>
<h3>Transformation 1: Parse</h3>
<p>The first transformation is parsing YAML into a sequence of &quot;parse events&quot;.
This is by far the hardest transformation, not just for YS but for any YAML
processor.
Sadly, it's so hard that only a few of the dozens of YAML processors out there
actually do it correctly.
See: <a href="https://matrix.yaml.info/">https://matrix.yaml.info/</a></p>
<p>On the other hand, this is actually the simplest part for the YS compiler to
implement.
Why?
Because it uses somebody else's YAML parser!!</p>
<blockquote>
<p>Note: YS currently uses the
<a href="https://bitbucket.org/snakeyaml/snakeyaml-engine">SnakeYAML Engine</a> framework
(only for it's YAML 1.2 parser component).
Later we plan to use <a href="https://github.com/pantoniou/libfyaml">libfyaml</a> which is
currently considered the best YAML parser in the world.
SnakeYAML was the obvious first choice because it's written in Java, YS is
written in Clojure and Clojure is a JVM language.
It's doing a great job for now!</p>
</blockquote>
<p>This is a good time to mention that the YAML data language spec describes
&quot;loading&quot; YAML text into native data structures as a several step process of
states and transformations.
In reality, the YS compiler is really just a very fancy YAML loader!</p>
<p>YAML parsers typically produce 10 different kinds of parse events:</p>
<ul>
<li>Start Stream</li>
<li>End Stream</li>
<li>Start Document</li>
<li>End Document</li>
<li>Start Sequence</li>
<li>End Sequence</li>
<li>Start Mapping</li>
<li>End Mapping</li>
<li>Scalar Value</li>
<li>Alias Reference</li>
</ul>
<p>YS (currently) doesn't care about the first 4 events, so it just ignores them.</p>
<p>That leaves use with a mapping containing 2 key/value pairs:</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:+</span> <span class="token string">"+MAP"</span><span class="token punctuation">,</span> <span class="token symbol">:!</span> <span class="token string">"yamlscript/v0"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span><span class="token symbol">:+</span> <span class="token string">"=VAL"</span><span class="token punctuation">,</span> <span class="token symbol">:=</span> <span class="token string">"name ="</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span><span class="token symbol">:+</span> <span class="token string">"=VAL"</span><span class="token punctuation">,</span> :$ <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span><span class="token symbol">:+</span> <span class="token string">"=VAL"</span><span class="token punctuation">,</span> <span class="token symbol">:=</span> <span class="token string">"say"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span><span class="token symbol">:+</span> <span class="token string">"=VAL"</span><span class="token punctuation">,</span> :$ <span class="token string">"Hello, $name!"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span><span class="token symbol">:+</span> <span class="token string">"-MAP"</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre>
<p>We are showing this state as a Clojure data structure and that's the kind of
serialization that we use in the YS compiler tests.</p>
<p>Here's a quick breakdown of the mapping keywords used above:</p>
<ul>
<li><code>:+</code> is the parse event type</li>
<li><code>:!</code> is the (optional) YAML tag</li>
<li><code>:=</code> is a plain (unquoted) scalar value</li>
<li><code>:$</code> is a double quoted scalar value</li>
</ul>
<p>That was a lot of info, but hopefully it sets the stage for the rest of this
post.</p>
<p>If you are interested in seeing how all this is implemented, check out:</p>
<ul>
<li><a href="https://github.com/yaml/yamlscript/tree/main/core/src/yamlscript">All the YS transformation libraries source code</a></li>
<li>The YS Test Suite Files:
<ul>
<li><a href="https://github.com/yaml/yamlscript/blob/main/core/test/compiler-stack.yaml">https://github.com/yaml/yamlscript/blob/main/core/test/compiler-stack.yaml</a></li>
<li><a href="https://github.com/yaml/yamlscript/blob/main/core/test/compiler.yaml">https://github.com/yaml/yamlscript/blob/main/core/test/compiler.yaml</a></li>
</ul>
</li>
</ul>
<h3>Transformation 2: Compose</h3>
<p>The second transformer is called the composer (in the <code>yamlscript.composer</code>
library).</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">{</span><span class="token symbol">:!</span> <span class="token string">"yamlscript/v0"</span><span class="token punctuation">,</span><br> :% <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:=</span> <span class="token string">"name ="</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:$ <span class="token string">"Clojure"</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:=</span> <span class="token string">"say"</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:$ <span class="token string">"Hello, $name!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre>
<p>Its simple job is to take the parse events and compose them into a tree of
mapping, sequence and scalar nodes.</p>
<p>It preserves the node's tag if any.</p>
<p>Here we see a new keyword <code>:%</code> which is used for a mapping node.
Sequence nodes use the keyword <code>:-</code> but they only show up in data mode, which we
aren't using here.</p>
<p>Now we have all the important information from the YAML input in an AST form
that we can refine (transform) a few more times until it becomes a Clojure AST!</p>
<h3>Transformation 3: Resolve</h3>
<p>YAML tags are rarely seen in the wild.
Many YAML users don't even know they exist.
But tags play an important role in the YAML load process.
Internally every single untagged node is assigned a tag based on heuristics that
consider its kind, position and content.</p>
<p>This process is called &quot;tag resolution&quot; and it's what we are doing here:</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">{</span><span class="token symbol">:ysm</span><br> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:ysx</span> <span class="token string">"def name"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:ysi</span> <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:ysx</span> <span class="token string">"say"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:ysi</span> <span class="token string">"Hello, $name!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre>
<p>Notice that all the keywords changed to <code>:ys?</code> here.
This is how YS stores the tag.
Each tag knows what kind of node it is attached to (map, seq or scalar) so, to
keep things simple, it doesn't store that info in the AST.</p>
<blockquote>
<p>Note: Keeping the structure of each state AST as simple as possible is a key
concern of the YS compiler.
It makes it easier to see what's going on when debugging and even more
importantly, it makes it easier to write tests for each transformation.</p>
</blockquote>
<p>The keywords seen above are:</p>
<ul>
<li><code>:ysm</code> is a code mode mapping node</li>
<li><code>:ysi</code> is a scalar that supports interpolation</li>
<li><code>:ysx</code> is a ys expression (a string of code to be further parsed)</li>
</ul>
<p>Tags are are essentially the names of the transformations that will be applied
to the node in the following transformation.</p>
<h3>Transformation 4: Build</h3>
<p>The build transformation is where a lot of the magic happens.</p>
<p>Most importantly, it's where scalars containing YAMLScript expressions are lexed
and parsed into Clojure expression ASTs.</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">{</span><span class="token symbol">:ysm</span><br> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> def<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span><span class="token punctuation">]</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Sym</span> say<span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Lst</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> str<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Hello, "</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre>
<p>For instance we can see that the simple string expression &quot;def name&quot; was parsed
into 2 Clojure symbol nodes: <code>{:Sym def}</code> and <code>{:Sym name}</code>.</p>
<p>We can also see that the string expression &quot;Hello, $name!&quot; was parsed into a an
interpolated string expression that joins string literals and variable values
into a single string.</p>
<p>One important aspect of the build output AST is that it retains the original
structure of the YAML input.
Mappings still have key/value pairs, and the key info stays separate from the
value info.</p>
<h3>Transformation 5: Transform</h3>
<p>The transformer transformation (that's a bit awkward I'll admit) is where
&quot;special cases&quot; are handled.</p>
<p>Not much happens in this stage yet.
In fact nothing at all happened in this example.</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">{</span><span class="token symbol">:ysm</span><br> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> def<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span><span class="token punctuation">]</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Sym</span> say<span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Lst</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> str<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Hello, "</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre>
<p>It's exactly the same as the build output.</p>
<p>In the future, the transform stage is where we will add support for letting
users defined their own syntax and semantic transformations for specific
functions.
If you know about Lisp macros, this will be something spiritually similar.</p>
<p>If you happen to think a particular function should be coded a specific way,
you'll be able to make it so.
As long as you don't break the rules of physics... or YAML!</p>
<p>Note that even though this transformation can change the AST quite a bit, it
still retains its overall YAML structure.</p>
<h3>Transformation 6: Construct</h3>
<p>The constructor phase's job is simple.
Turn the final YAML structured AST into an AST that directly represents the
intended Clojure code compilation result.</p>
<p>It does this essentially by applying the function asscoiated with a node's tag
to the node's value.</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">{</span><span class="token symbol">:Lst</span><br> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> do<span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Lst</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> def<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Clojure"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Lst</span><br>   <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> say<span class="token punctuation">}</span><br>    <span class="token punctuation">{</span><span class="token symbol">:Lst</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> str<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Hello, "</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre>
<p>Every node in this AST directy represents a Clojure code construct.
Voila!</p>
<h3>Transformation 7: Print</h3>
<p>Just like in any Lisp, a Clojure AST &quot;prints&quot; directly to Clojure code.
This is because every node in the AST is essentially a token that knows how to
print itself!</p>
<p>Again here's our final AST:</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">{</span><span class="token symbol">:Lst</span><br> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> do<span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Lst</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> def<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Clojure"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Lst</span><br>   <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> say<span class="token punctuation">}</span><br>    <span class="token punctuation">{</span><span class="token symbol">:Lst</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> str<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Hello, "</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre>
<p>The <code>yamlscript.printer/print</code> function converts that to this string (of Clojure
code):</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token string">"(def name \"Clojure\")\n(say (str \"Hello, \" name \"!\"))\n"</span></code></pre>
<p>When that string is printed out, it looks like this:</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">def</span> name <span class="token string">"Clojure"</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span><span class="token function">say</span> <span class="token punctuation">(</span><span class="token keyword">str</span> <span class="token string">"Hello, "</span> name <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>Aaaand, we're done!</p>
<h3>Transformation 1-7: Compile</h3>
<p>The YAMLScript compiler is just all the above crammed together is sequence;
passing YS input through the 7 transformations we just described.</p>
<p>I'd like to show you the actual YAMLScript <code>compile</code> function (written in
Clojure):</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">defn</span> compile<br>  <span class="token string">"Convert YAMLScript code string to an equivalent Clojure code string."</span><br>  <span class="token punctuation">[</span><span class="token operator">^</span>String yamlscript-string<span class="token punctuation">]</span><br>  <span class="token punctuation">(</span><span class="token keyword">->></span> yamlscript-string<br>    yamlscript.parser/parse<br>    yamlscript.composer/compose<br>    yamlscript.resolver/resolve<br>    yamlscript.builder/build<br>    yamlscript.transformer/transform<br>    yamlscript.constructor/construct<br>    yamlscript.printer/print<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>Pretty straightforward, right?
Or if you are more familiar with YAMLScript than Clojure:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">defn compile(yamlscript-string)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">"Convert YAMLScript code string to an equivalent Clojure code string."</span><span class="token punctuation">:</span><br>  <span class="token key atrule">->></span><span class="token punctuation">:</span><br>    yamlscript<span class="token punctuation">-</span>string<br>    yamlscript.parser/parse<br>    yamlscript.composer/compose<br>    yamlscript.resolver/resolve<br>    yamlscript.builder/build<br>    yamlscript.transformer/transform<br>    yamlscript.constructor/construct<br>    yamlscript.printer/print</code></pre>
<p>I hope I didn't waste too much of your Sunday on this post.
I know it was a lot to take in, and I also know you don't need to know all this
to be a good YAMLScript programmer.</p>
<p>But then again, you probably want to know all about this to become a great one!</p>
<p>See you tomorrow for Day 11 of the YAMLScript Advent Calendar.</p>
<p>&nbsp;</p>
<details><summary style="color:#888">Santa's little secrets...</summary>
<p>In December 2023 YAMLScript is a work in progress.</p>
<p>This is not to say that it's vaporware, or a toy proof of concept.
It has a working compiler, runtime and CLI.
It has unit tests that must pass for every commit pushed to the main branch.
It's well thought out and has a clear direction that I continually vet with a
small group of talented and trusted people.</p>
<p>But that in turn not to say that you should use it in production today.
I encourage you to start playing with it, and I'm committed to backwards
compatibility for stable releases.
But we're not quite there yet.
Caveat usor!</p>
<p>YAMLScript is evolving fast.
While I'm writing these posts, I'm also writing the code for new features and
fixing bugs as I go.
I've had the Advent plan for over a month now, and I had planned to be further
along before December 1st, but such are the time estimates of hackers.</p>
<p>I am attempting to make sure that the code examples in these posts are always
using the implemented features, but sometimes I may fall a few hours behind.
Often I need to write the examples using code patterns that actually work but
are not the ones I preferred to best make a point.</p>
<p>As I fix bugs, implement features and tweak the language, I will update the
posts accordingly.
If you see something that bugs you, try taking another look after a few days.
It probably bugged me too!</p>
<p>Be patient with me.</p>
<p>If I had to guess, I'd say that YAMLScript v0 will be have a stable release
sometime before March 2024.
I'll continue blogging the progress as I go, so it shouldn't be hard for you to
decide when to start using YAMLScript for real.</p>
<p>Overall the whole thing is going extremely well, and I'm having a lot of fun.
It's important to be transparent with you about where things are at.</p>
<p>Stick with me... This is going to be awesome!</p>
<p>— Ingy döt Net</p>
</details>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>The YeS Express</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-11/"/>
      <updated>2023-12-11T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-11/</id>
      <content type="html">
        <![CDATA[
      <p>Santa's got a lot of ground to cover in a short amount of time.
He doesn't have time to deal with confusing maps and directions.</p>
<p>Lisp has other-worldly powers of abstraction, but when it comes to reading
syntax, most people prefer the familiarity of this world.</p>
<p>YAMLScript fully embraces all that Clojure has to offer, but syntax-wise it
also offers a more familiar face.</p>
<h3>Welcome to Day 11 of the YAMLScript Advent Calendar!</h3>
<p>Today we'll look at YAMLScript Expressions, aka YeS-Expressions.
Lisp has S-Expressions, YAMLScript has YeS-Expressions!</p>
<p>When writing YAMLScript instructions in &quot;code mode&quot; you are always working with
3 basic YAML elements:</p>
<ul>
<li>YAML Block Mappings - The indented style <code>key: value</code> pairs</li>
<li>YAML Quoted Scalars - String literals</li>
<li>YAML Plain Scalars - The unquoted <code>value</code> scalars</li>
</ul>
<p>YAMLScript treats all YAML plain scalars as YeS-Expressions (ysexprs).</p>
<p>Let's look at some examples.</p>
<h3>Infix Expressions</h3>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">x =</span><span class="token punctuation">:</span> (y * 2)<br><span class="token key atrule">z =</span><span class="token punctuation">:</span> (x + 5 + y)</code></pre>
<p>Compiles to Clojure (Lisp) like this:</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">def</span> x <span class="token punctuation">(</span><span class="token keyword">*</span> y <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span><span class="token keyword">def</span> z <span class="token punctuation">(</span><span class="token keyword">+</span> x <span class="token number">5</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>YeS-Expressions support infix operators for very simple expressions.
If you put exactly 3 forms in parentheses, and the second one is an operator,
then the first and third forms are operands.
The compiler will swap the first and second forms making it work like Lisp wants
it to.</p>
<p>If you have a parenthesized expression with more than 2 operands and the
operators are all the same, then the compiler will make a Lisp form starting
with the operator and followed by the operands.</p>
<blockquote>
<p>Note: In rare cases in Lisp <code>(a + 1)</code> is valid when <code>a</code> is a function that
takes two arguments, an operator function add a number in this case.
There are ways to specifiy this in YAMLScript, but we won't cover them here.</p>
</blockquote>
<p>In simple cases where the infix expression is the only thing in the YAML scalar,
you can omit the parentheses.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">x =</span><span class="token punctuation">:</span> y * 2<br><span class="token key atrule">z =</span><span class="token punctuation">:</span> x + 5 + y</code></pre>
<p>Note that YAMLScript has no support for operator precedence.
You must use parentheses to group expressions and group operations in triplets.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">x =</span><span class="token punctuation">:</span> ((y * 2) + 5) / 2</code></pre>
<h3>Prefix Expressions</h3>
<p>In Lisp you might see a function call like this:</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token function">abspath</span> <span class="token punctuation">(</span><span class="token keyword">join</span> <span class="token string">"/"</span> <span class="token punctuation">[</span><span class="token string">"foo"</span> <span class="token string">"bar"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>Many non-Lisp languages would write this as:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token function">abspath</span><span class="token punctuation">(</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>YAMLScript supports this style of function call as well.</p>
<p>YAMLScript is very flexible about how you can write function calls.
You could do the above in all the ways below:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">path1 =</span><span class="token punctuation">:</span> abspath(join("/" <span class="token punctuation">[</span>"foo" "bar"<span class="token punctuation">]</span>))<br><span class="token key atrule">path2 =</span><span class="token punctuation">:</span> (abspath (join "/" <span class="token punctuation">[</span>"foo" "bar"<span class="token punctuation">]</span>))<br><span class="token key atrule">path3 =</span><span class="token punctuation">:</span><br>  <span class="token key atrule">abspath</span><span class="token punctuation">:</span><br>    <span class="token key atrule">join "/"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>"foo" "bar"<span class="token punctuation">]</span><br><span class="token key atrule">=></span><span class="token punctuation">:</span> (def path4 abspath(join("/" <span class="token punctuation">[</span>"foo" "bar"<span class="token punctuation">]</span>)))</code></pre>
<p>Look closely at the last example (<code>path4</code>).
It looks like a Clojure form, but it actually makes use of prefix function
calls.</p>
<h3>Special Operators</h3>
<p>YAMLScript has a few special operators that are not part of Clojure.</p>
<p>The <code>..</code> operator is used to create a range of consectutive integers.
The expression <code>(1 .. 3)</code> is equivalent to the Clojure form <code>(range 1 4)</code> and
evaluates to the list <code>(1 2 3)</code>.
The expression <code>(3 .. 1)</code> is equivalent to the Clojure form <code>(range 3 0 -1)</code> and
evaluates to the list <code>(3 2 1)</code>.</p>
<p>The <code>+</code> and <code>*</code> operators are polymorphic.</p>
<ul>
<li><code>&quot;x&quot; * 3</code> -&gt; <code>&quot;xxx&quot;</code></li>
<li><code>&quot;x&quot; + &quot;y&quot; + &quot;z&quot;</code> -&gt; <code>&quot;xyz&quot;</code></li>
<li><code>{a: 1} + {b: 2}</code> -&gt; <code>{a: 1, b: 2}</code></li>
<li><code>[1 2] + [3 4]</code> -&gt; <code>[1 2 3 4]</code></li>
</ul>
<h3>Special Thanks</h3>
<p>I'd like to say thank you to David A. Wheeler for his web page <a href="https://dwheeler.com/readable/sweet-expressions.html">Curly infix,
Modern-expressions, and Sweet-expressions: A suite of readable formats for
Lisp-like languages</a>.</p>
<p>I adapted many of those ideas to make YeS-Expressions.</p>
<h3>Conclusion</h3>
<p>As I've said before, YAMLScript is very flexible, allowing you to decide how
much Lisp or YAML style you want to use at any point.
YeS-Expressions allow you to lean to the Lisp but keep it readable for your
non-Lisper friends.</p>
<p>Join me tomorrow for Day 12 of the YAMLScript Advent Calendar.</p>
<p>&nbsp;</p>
<details><summary style="color:#888">Santa's little secrets...</summary>
<p>In December 2023 YAMLScript is a work in progress.</p>
<p>This is not to say that it's vaporware, or a toy proof of concept.
It has a working compiler, runtime and CLI.
It has unit tests that must pass for every commit pushed to the main branch.
It's well thought out and has a clear direction that I continually vet with a
small group of talented and trusted people.</p>
<p>But that in turn not to say that you should use it in production today.
I encourage you to start playing with it, and I'm committed to backwards
compatibility for stable releases.
But we're not quite there yet.
Caveat usor!</p>
<p>YAMLScript is evolving fast.
While I'm writing these posts, I'm also writing the code for new features and
fixing bugs as I go.
I've had the Advent plan for over a month now, and I had planned to be further
along before December 1st, but such are the time estimates of hackers.</p>
<p>I am attempting to make sure that the code examples in these posts are always
using the implemented features, but sometimes I may fall a few hours behind.
Often I need to write the examples using code patterns that actually work but
are not the ones I preferred to best make a point.</p>
<p>As I fix bugs, implement features and tweak the language, I will update the
posts accordingly.
If you see something that bugs you, try taking another look after a few days.
It probably bugged me too!</p>
<p>Be patient with me.</p>
<p>If I had to guess, I'd say that YAMLScript v0 will be have a stable release
sometime before March 2024.
I'll continue blogging the progress as I go, so it shouldn't be hard for you to
decide when to start using YAMLScript for real.</p>
<p>Overall the whole thing is going extremely well, and I'm having a lot of fun.
It's important to be transparent with you about where things are at.</p>
<p>Stick with me... This is going to be awesome!</p>
<p>— Ingy döt Net</p>
</details>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Future Proof</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-12/"/>
      <updated>2023-12-12T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-12/</id>
      <content type="html">
        <![CDATA[
      <p>Santa has very little margin for error.
He has to get everything just right all in one night.</p>
<p>YAMLScript is a work in progress, and will be for a long time.
I'm trying to get it right, but I'm no Santa!
In fact I'm quite sure I'll get some things wrong.
That's just the nature of the beast when you're a programmer.</p>
<p>Also, have you ever wondered why the magic YAMLScript starter tag has that <code>/v0</code>
at the end?</p>
<h3>Welcome to Day 12 of the YAMLScript Advent Calendar!</h3>
<p>Today we'll discuss how YAMLScript is designed to be future proof.</p>
<p>I've been programming for quite a long time now.
I've learned that no matter how good I think an idea it today, I'll almost
certainly think of a better way to do it in the future.</p>
<p>This means I'll almost certainly want to make big changes to YAMLScript long
after it's in use in the real world.</p>
<p>I also believe that it is really important for things like APIs and progamming
languages to be stable and backwards compatible, basically forever.</p>
<p>If I could always have the freedom to make big changes to YAMLScript, but never
break backwards compatibility, then I could have my cake and eat it too.
And I think I can!</p>
<h3>The YAMLScript API Version</h3>
<p>I call <code>v0</code> the YAMLScript API version.
YAMLScript v0 isn't done yet, but it should be in the next couple months.
At that point I'll release it as a stable version of the API version <code>0</code>.</p>
<p>So you've seen that to make a <code>.ys</code> file executable, you need to add a special
starter tag to the top of the file:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token punctuation">---</span> <span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"Hello!"</span></code></pre>
<p>Or you can write it with the shebang line:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment">#!/usr/bin/env ys-0</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"Hello!"</span></code></pre>
<p>Leaving off that <code>0</code> here will make things not work as you intended.</p>
<p>You might also have noticed that when you install the <code>ys</code> binary CLI is is a
symlink to <code>ys-0.1.26</code>.
And there is another symlink called <code>ys-0</code> that points to <code>ys-0.1.26</code>.</p>
<p>This is all by design.</p>
<p>The leading <code>0</code> in <code>!yamlscript/v0</code> and in <code>bin/ys-0</code> and also in <code>0.1.26</code> is
the YAMLScript API version.</p>
<p>When YAMLScript v0 is declared stable, there will never be changes that break
backwards compatibility with the <code>v0</code> API version.</p>
<p>That means you can write YAMLScript programs today, and they will continue to
work forever, even if you upgrade to a new version of YAMLScript.</p>
<h3>New Versions of YAMLScript</h3>
<p>At some point after YAMLScript v0 is released as stable, I'll start working on
YAMLScript v1.</p>
<p>I can make any changes I want in YAMLScript v1, even ones that break backwards
compatibility with YAMLScript v0.
That's because I set up the rules such that you need to declare the version when
you write a YAMLScript program.</p>
<h3>Conclusion</h3>
<p>This doesn't mean that I don't think extremely carefully about every change I
make to YAMLScript.
But it does mean that I don't have to worry about everything being perfect
before I release stable v0.</p>
<p>That's exciting as I strive to make YAMLScript a great language today and a
better language in the future.</p>
<p>I hope that also encorages you write more YAMLScript today, knowing that it will
continue to work in the future.</p>
<p>That wraps up Day 12.
And that also means we're half way through the Advent Calendar.
I hope you're enjoying it as much as I am, and I hope the best is yet to come!</p>
<p>Tune in tomorrow for Day 13 of the YAMLScript Advent Calendar.</p>
<p>&nbsp;</p>
<details><summary style="color:#888">Santa's little secrets...</summary>
<p>In December 2023 YAMLScript is a work in progress.</p>
<p>This is not to say that it's vaporware, or a toy proof of concept.
It has a working compiler, runtime and CLI.
It has unit tests that must pass for every commit pushed to the main branch.
It's well thought out and has a clear direction that I continually vet with a
small group of talented and trusted people.</p>
<p>But that in turn not to say that you should use it in production today.
I encourage you to start playing with it, and I'm committed to backwards
compatibility for stable releases.
But we're not quite there yet.
Caveat usor!</p>
<p>YAMLScript is evolving fast.
While I'm writing these posts, I'm also writing the code for new features and
fixing bugs as I go.
I've had the Advent plan for over a month now, and I had planned to be further
along before December 1st, but such are the time estimates of hackers.</p>
<p>I am attempting to make sure that the code examples in these posts are always
using the implemented features, but sometimes I may fall a few hours behind.
Often I need to write the examples using code patterns that actually work but
are not the ones I preferred to best make a point.</p>
<p>As I fix bugs, implement features and tweak the language, I will update the
posts accordingly.
If you see something that bugs you, try taking another look after a few days.
It probably bugged me too!</p>
<p>Be patient with me.</p>
<p>If I had to guess, I'd say that YAMLScript v0 will be have a stable release
sometime before March 2024.
I'll continue blogging the progress as I go, so it shouldn't be hard for you to
decide when to start using YAMLScript for real.</p>
<p>Overall the whole thing is going extremely well, and I'm having a lot of fun.
It's important to be transparent with you about where things are at.</p>
<p>Stick with me... This is going to be awesome!</p>
<p>— Ingy döt Net</p>
</details>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>History Lesson</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-13/"/>
      <updated>2023-12-13T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-13/</id>
      <content type="html">
        <![CDATA[
      <p>Santa is Legend.
Legends have histories.
The histories of Santa are many and varied, some going back to the 4th century
AD.</p>
<p>YAMLScript's history is much shorter, but it's still a history.
Today I'd like to tell you a little bit about it.</p>
<h3>Welcome to Day 13 of the YAMLScript Advent Calendar!</h3>
<p>In the summer of 2022 I was gathering information about a computer system that I
was learning about.
I was putting the information into a YAML file.
At first I thought to myself, this YAML file could essentially be a
configuration file for running the system.
Then I thought, what if I could run the system by just &quot;running&quot; the YAML file?</p>
<p>Hmmmm... YAMLScript!
For me a project can only be started when it has a name.
I had the name, I loved the name, I loved the idea, I started the project!</p>
<p>I put together a prototype as a Perl module and published it to CPAN.
I knew that conceptually YAMLScript would be a Lisp, but to be honest I barely
knew what a Lisp was.</p>
<h3>One True YAML</h3>
<p>Earlier in the year I had come to the conclusion that the YAML spec and all of
the YAML implementations were too hard to fix.
I had spent the second half of 2021 trying to fix YAML, with a <a href="https://yaml.org/spec/1.2.2/ext/team/">core group</a> of five people, and it slowly became
obvious that it was a lost cause.
It was just too much work to get everyone to agree on anything, let alone
everything.</p>
<p>A possibly better solution was to create a new YAML framework (based on the
current YAML 1.2 spec) and publish it in 42 different languages.</p>
<p>At least this way there would be a set of quality YAML implementations that were
the same in every language.
The main problem with this idea was simply learning (and remembering!) how to
publish a library in 42 different languages!</p>
<p>I decided to write a meta publishing framework that would allow me to publish
to any language using the same simple commands.
I called this framework <a href="https://github.com/ingydotnet/pst">PST - Package Super Tool</a>.</p>
<p>In doing that I had to pick 42 languages and start learning a bit about each of
them.
At some point I came across Clojure and thought it was interesting.</p>
<h3>Make a Lisp</h3>
<p>Around the start of 2023 I started thinking about YAMLScript again.
My fledgling language with just a toy implementation in Perl.
I knew YAMLScript was going to be a Lisp, but I didn't know much about Lisps.
I asked the internet how to make a Lisp and it told me to read <a href="https://github.com/kanaka/mal/blob/master/process/guide.md">Make a Lisp</a>!</p>
<p>Make a Lisp (Mal) is a project that walks you through making a baby
Clojure-inspired Lisp implementation in the programming language of your choice.
It has eleven chapters, each with a set of tests that you must pass before you
can move on to the next chapter.
At the end you have a working Lisp implementation and you have to use it to run
the Mal implementation written in Mal and make sure it passes all the tests!</p>
<p>I decided to do Mal in Perl (even though there was already a Perl
implementation).
There are nearly 100 implementations of Mal in over 70 different languages.
It took me about 2 weeks to get through the whole thing.
By the end I really felt like I knew what a Lisp was, how Lisps worked and how
to make one.</p>
<p>When I finish the Mal course I decided to do it again but this time in
YAMLScript, a language that didn't exist yet.
This was really easy and fun.
I just ported the Mal in Mal code to a YAML form that I found pleasing and
acceptable as a programming language; essentially making up YAMLScript as I went
along.</p>
<p>I also wanted to go much further with the Perl implementation.
I decided I would create a full implementation of Clojure on Perl based off of
my Mal in Perl code.
I call this project <a href="https://github.com/lingy-lang/lingy">Lingy</a> (currently
<a href="https://metacpan.org/dist/Lingy">available on CPAN</a>).
This is when I started learning Clojure. (Spring 2023).</p>
<h3>TPRC 2023</h3>
<p>I was also helping to organize the <a href="tprc.to">TPRC 2023</a> (Perl and Raku)
conference.
I decided I would give a talk called <a href="https://www.youtube.com/watch?v=9OcFh-HaCyI">Lingy and YAMLScript</a>.
I had to get a working Lingy and a working YAMLScript implementation in Perl by
the end of June.</p>
<p>After I gave the talk I noticed it was getting a lot of attention.
A lot more views on youtube than any other talk at the conference.
I realized this was happening because the words &quot;Clojure&quot; and &quot;Java&quot; were in the
talk description.</p>
<h3>The Clojure Community</h3>
<p>A lovely man named Peter Strömberg reached out to me and asked if I would be
interested in joining the <a href="https://clojurians.slack.com/">Clojure Community Slack</a>.
Peter is the author of <a href="https://calva.io/">Calva</a>, a Clojure IDE for VS Code,
one of the best ways to write and work with Clojure.
I joined right away and he pointed me in all the right directions and got me
talking to all the right people.</p>
<p>I soon learned about <a href="https://www.graalvm.org/">GraalVM</a> and <a href="https://github.com/babashka/sci">SCI</a> written by Michiel Borkent, a man to whom I owe
much credit for helping me with many deep technical issues I encountered.
Michiel is the author of <a href="https://babashka.org/">Babashka</a>, a popular way to do
shell scripting in Clojure.
SCI is the Clojure runtime engine that Babashka uses and that YAMLScript now
uses as well!</p>
<p>All the pieces started falling into place, and I got a clear vision of what
YAMLScript should become... AND how relatively easy it would be to make it
happen thanks to the Clojure ecosystem.
I started rewriting the YAMLScript compiler and runtime in Clojure and
rebuilding it into what it is today.</p>
<h3>December 1st, 2023</h3>
<p>At some point in the Fall, I decided that I would start blogging about
YAMLScript every day in December 2023, in the Programming Project Advent
Calendar style.</p>
<p>I thought I would easily get everything done by Dec 1st but to be honest, even
as I write this now, there is still so much to do.
Some days I really want to write about a particular topic, but the code isn't
quite ready yet.</p>
<p>But all that said, it's all working out pretty dang well.
I'm loving this language and project!</p>
<p>I have the highest hopes of hopes for YAMLScript in 2024.</p>
<p>There's a lot more details I could add here but it's getting late and I need to
get some sleep.</p>
<h3>Join me again tomorrow for Day 14 of the YAMLScript Advent Calendar!</h3>
<p>&nbsp;</p>
<details><summary style="color:#888">Santa's little secrets...</summary>
<p>In December 2023 YAMLScript is a work in progress.</p>
<p>This is not to say that it's vaporware, or a toy proof of concept.
It has a working compiler, runtime and CLI.
It has unit tests that must pass for every commit pushed to the main branch.
It's well thought out and has a clear direction that I continually vet with a
small group of talented and trusted people.</p>
<p>But that in turn not to say that you should use it in production today.
I encourage you to start playing with it, and I'm committed to backwards
compatibility for stable releases.
But we're not quite there yet.
Caveat usor!</p>
<p>YAMLScript is evolving fast.
While I'm writing these posts, I'm also writing the code for new features and
fixing bugs as I go.
I've had the Advent plan for over a month now, and I had planned to be further
along before December 1st, but such are the time estimates of hackers.</p>
<p>I am attempting to make sure that the code examples in these posts are always
using the implemented features, but sometimes I may fall a few hours behind.
Often I need to write the examples using code patterns that actually work but
are not the ones I preferred to best make a point.</p>
<p>As I fix bugs, implement features and tweak the language, I will update the
posts accordingly.
If you see something that bugs you, try taking another look after a few days.
It probably bugged me too!</p>
<p>Be patient with me.</p>
<p>If I had to guess, I'd say that YAMLScript v0 will be have a stable release
sometime before March 2024.
I'll continue blogging the progress as I go, so it shouldn't be hard for you to
decide when to start using YAMLScript for real.</p>
<p>Overall the whole thing is going extremely well, and I'm having a lot of fun.
It's important to be transparent with you about where things are at.</p>
<p>Stick with me... This is going to be awesome!</p>
<p>— Ingy döt Net</p>
</details>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>2023 Advent Index</title>
      <link href="https://yamlscript.org/posts/advent-2023/index/"/>
      <updated>2023-12-25T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/index/</id>
      <content type="html">
        <![CDATA[
      <h3>Welcome to the 2023 YAMLScript Advent Blog!</h3>
<p>&nbsp;</p>
<h3><a href="/posts/advent-2023/dec-13">Dec 13 - History Lesson</a></h3>
<h3><a href="/posts/advent-2023/dec-12">Dec 12 - Future Proof</a></h3>
<h3><a href="/posts/advent-2023/dec-11">Dec 11 - The YeS Express</a></h3>
<h3><a href="/posts/advent-2023/dec-10">Dec 10 - States and Ladders</a></h3>
<h3><a href="/posts/advent-2023/dec-09">Dec 9 - Coding with Style</a></h3>
<h3><a href="/posts/advent-2023/dec-08">Dec 8 - Going to the Library</a></h3>
<h3><a href="/posts/advent-2023/dec-07">Dec 7 - Sharpen Your Tools</a></h3>
<h3><a href="/posts/advent-2023/dec-06">Dec 6 - Modes of Transportation</a></h3>
<h3><a href="/posts/advent-2023/dec-05">Dec 5 - Unwrapping Gifts</a></h3>
<h3><a href="/posts/advent-2023/dec-04">Dec 4 - Santa's Big Secret</a></h3>
<h3><a href="/posts/advent-2023/dec-03">Dec 3 - Load em Up!</a></h3>
<h3><a href="/posts/advent-2023/dec-02">Dec 2 - Twas a Bit</a></h3>
<h3><a href="/posts/advent-2023/dec-01">Dec 1 - YAMLScript Advent 2023</a></h3>
<!--
### [Dec 14 - ???](/posts/advent-2023/dec-14)
### [Dec 15 - ???](/posts/advent-2023/dec-15)
### [Dec 16 - ???](/posts/advent-2023/dec-16)
### [Dec 17 - ???](/posts/advent-2023/dec-17)
### [Dec 18 - ???](/posts/advent-2023/dec-18)
### [Dec 19 - ???](/posts/advent-2023/dec-19)
### [Dec 20 - ???](/posts/advent-2023/dec-20)
### [Dec 21 - ???](/posts/advent-2023/dec-21)
### [Dec 22 - ???](/posts/advent-2023/dec-22)
### [Dec 23 - ???](/posts/advent-2023/dec-23)
### [Dec 24 - ???](/posts/advent-2023/dec-24)
-->

    ]]>
      </content>
    </entry>
  
</feed>